\chapter{Declaratief Programmeren} \label{chap:decl}

\section{Overzicht} \label{sec:decl-overz}

Traditioneel wordt software geschreven in imperatieve programmeertalen. Deze manier van werken vertrekt van het principe dat men de computer opdrachten geeft, en de computer deze \'e\'en voor \'e\'en uitvoert. De programmeur blijft echter verantwoordelijk voor het vinden van een oplossingswijze voor zijn probleem. Dit is wat men in declaratieve talen probeert te vermijden: de programmeur specificeert enkel het probleem, en de computer zoekt een (effici\"ente) oplossingsstrategie.

In \cite{kowalski} wordt dan ook gesteld: een algoritme is logica + controle. De logica beschrijft waaraan het resultaat moet voldoen, de controle beschrijft hoe dit resultaat bereikt moet worden. In een declaratieve taal wordt geprobeerd de controle los te koppelen van het programma.

Er zijn verschillende paradigma's die gehanteerd worden om het probleem te beschrijven. Elk geeft aanleiding tot een eigen klasse declaratieve programmeertaal: \begin{itemize}
\item Logic Programming: het probleem wordt omschreven aan de hand van eerste-orde logica.
\item Constraint Programming: het probleem wordt omschreven als een reeks beperkingen op een verzameling variabelen over een (eindig) domein.
\item Constraint Logic Programming: een combinatie van bovenstaande methodes.
\end{itemize}

De voordelen van declaratief programmeren zijn duidelijk. Men ontlast de programmeur van hoe een probleem op te lossen. De bekomen programma's zijn voor veel problemen heel eenvoudig, elegant en overzichtelijk. Kennis van hoe de uitvoering van de bekomen programma's verloopt, kan nuttig zijn om de effici\"entie op te drijven, maar is in principe niet essentieel om programma's te kunnen schrijven of begrijpen, wat bij imperatieve talen wel het geval is.

\section{Constraint Programming}

Constraint Programming stelt dat een programma moet bestaan uit een aantal beperkingen die op een aantal variabelen opgelegd worden. Die variabelen zijn dan elementen van een bepaald eindig of oneindig domein, en het zoeken naar oplossingen kan op verschillende manieren gebeuren, afhankelijk van de aard van het probleem. Deze inleiding is gebaseerd op \cite{bartak99constraint}.

Een constraint is in feite een veralgemening van een vergelijking: ze legt een voorwaarde op aan \'e\'en of meerdere variabelen, en stelt dat niet elke combinatie van variabelen mag voorkomen. Er worden twee grote groepen van problemen onderscheiden, Constraint Satisfaction Problems (CSP), en Constraint Solving. Het belangrijkste verschil tussen beiden is de grootte van het domein waarover het probleem handelt. Bij een CSP is dit een eindige verzameling, waarvan de mogelijke waarden niet noodzakelijk numeriek hoeven te zijn. De oplossingsstrategie bestaat dan ook algemeen gezien uit het overlopen van verschillende mogelijkheden of het beperken van mogelijkheden tot er zo weinig mogelijk overblijven. Bij Constraint Solving zijn de domeinen groter, en het overlopen van combinaties is ongeschikt om deze op te lossen. Er wordt dan ook meer beroep gedaan op wiskundige methodes.

Bij het zoeken naar oplossingen voor CSP, kan het zijn dat men ge\"interesseerd is in een arbitraire oplossing, in alle oplossingen, of in de beste (of althans zo goed mogelijke) oplossing. Een oplossing bestaat uit een reeks variabele-toewijzingen zodat alle variabelen tegelijk aan alle opgelegde beperkingen voldoen.

\subsection{Systematisch zoeken}

De eenvoudigste manier om een CSP op te lossen is simpelweg mogelijkheden af te lopen en te controleren of aan de beperkingen voldaan is. Deze methode heet ``Generate and Test''. Indien er een conflict gevonden wordt (een constraint waar niet aan voldaan is), wordt een nieuwe waardentoewijzing gezocht.
Het is een heel simpele methode die zekerheid biedt \'e\'en of zelfs alle oplossingen te vinden, maar is heel ineffici\"ent. Het is mogelijk deze techniek te versnellen, door het genereren intelligenter te maken, en zo minder conflicterende mogelijkheden te genereren. Een andere mogelijkheid is de variabelen niet allen tegelijk, maar \'e\'en voor \'e\'en een waardentoewijzing geven, en zodra alle variabelen betrokken in een bepaalde constraint een waarde toegewezen hebben, de geldigheid van deze constraint nagaan. Indien dan een conflict optreedt, wordt naar de laatste variabele waar nog niet alle mogelijkheden voor geprobeerd waren teruggekeerd, en daarvoor de volgende mogelijkheid gekozen. Deze techniek, die ``backtracking'' genoemd wordt, is duidelijk beter dan pure Generate and Test, want er worden hele deelverzamelingen oplossingen reeds op voorhand uitgesloten. Ze leidt echter nog steeds vaak tot exponenti\"ele tijdscomplexiteit, al is dat niet altijd te vermijden.

\subsection{Consistentie technieken}

Een andere methode om tot een oplossing te komen, is het gebruik van consistentie-technieken. Deze komen neer op bijhouden welke mogelijkheden elke variabele nog heeft, en (vereenvoudigde) constraints gebruiken om mogelijkheden hiervan te snoeien. Er bestaan verschillende gradaties van consistentie-technieken, die steeds ingewikkeldere vormen van inconsistenties op voorhand kunnen verwijderen uit de mogelijkheden. Ze worden dan ook meestal gebruikt in combinatie met andere technieken om de overgebleven mogelijkheden af te gaan, indien consistentie-technieken niet tot een volledige oplossing kunnen komen.

Afhankelijk van de graad van consistentie worden deze technieken Node Consistency (NC), Arc Consistency (AC) of Path Consistency (PC) genoemd. NC technieken verwijderen enkel mogelijke waardes van variabelen die inconsistent zijn met een constraint op enkel die variabele. AC technieken kunnen mogelijkheden verwijderen die niet in combinatie met andere overblijvende waardes van andere variabelen kunnen voorkomen volgens constraints op twee variabelen. PC technieken gaan nog verder, door combinaties van drie variabelen toe te laten bij controles. Hoe hoger de graad van consistentie die nagestreefd wordt, hoe computationeel zwaarder het algoritme wordt echter. Er kan echter aangetoond worden dat de meeste van deze technieken niet compleet zijn, met andere woorden niet gegarandeerd de oplossing kunnen vinden. Een verdergaande uitleg kan gevonden worden in \cite{bartak01}. 

\subsection{Constraint-propagatie}

Systematisch zoeken is in staat altijd een oplossing te vinden, maar kan daar zeer lang over doen. Er zijn enkele bekende redenen waarom deze strategie overbodig veel werk vraagt. Zo is er trashing, het herhaaldelijk conflicten vinden om telkens dezelfde reden. Er is ook veel redundant werk, nl. conflicterende waardes die niet onthouden worden, en ten laatste het laattijdig ontdekken van conflicten.

Consistentie-technieken daarentegen beperken de zoekruimte snel, maar komen zeker niet altijd tot de oplossing. Daarom worden ze zoals gezegd meestal samen gebruikt. Er zijn hierbij 2 basistechnieken, Look Back en Look Ahead schemas.

Bij Look Back, worden consistentie technieken gebruikt tijdens het itereren, om zo conflicten tussen de variabelen die reeds een waarde toegewezen kregen te ontdekken. Backtracking is de eenvoudigste techniek hiervoor, die gewoon probeert inconsistenties te ontdekken en zo ja, voortgaat met de volgende waarde voor de laatste variabele. Backjumping verbetert deze techniek nog, door te analyseren welke variabelen het conflict veroorzaakten, en wanneer geen mogelijkheden overblijven terug te springen naar de conflicterende variabele in plaats van de laatste variabele. Er zijn nog enkele andere verbeteringen, zoals backchecking en backmarking, die gebaseerd zijn op het onthouden van conflicterende waardes, zodat ze niet opnieuw gecontroleerd moeten worden.

Alle methodes ontdekken echter nog steeds pas een conflict nadat het optreedt. Daarom gaat men in Look Ahead schemas consistentie technieken gaan toepassen op combinaties van variabelen die reeds wel en variabelen die nog geen waarde toegekend kregen, om zo toekomstige mogelijkheden te gaan uitsluiten, nog voor ze optreden. Hier zijn verschillende varianten van, die meestal AC technieken gebruiken. Meer informatie kan gevonden worden in de literatuur, bv. \cite{bartak01} en \cite{bartak99constraint}.

\section{Logic Programming}

De volgende vorm van declaratief programmeren waar even op ingegaan wordt, heet Logic Programming, of logisch programmeren. Deze techniek is gebaseerd op de wiskundige theorie van predikaatlogica. Een uitgebreide uitleg kan gevonden worden in \cite{introlp}.

\subsection{Predikaatlogica}

Predikaatlogica is een tak van de wiskunde die zich bezighoudt met het al dan niet waar zijn van logische formules. Het is een veralgemening van 
\TODO{Stuk over Logic Programming}

\section{Constraint Logic Programming}

Constraint Logic Programming (CLP) is een combinatie van Constraint Programming en Logic Programming. Aangezien beiden instanties zijn van hetzelfde probleem: ``geef me een oplossing die voldoet aan de eisen die gesteld worden'', is deze combinatie heel natuurlijk. In CLP breidt men de mogelijkheden van de logische taal uit, door toe te laten dat constraints gebruikt worden in de bodies van een clause. 

Hierbij wordt een ``constraint store'' toegevoegd aan de toestand van de taal, die mee hersteld wordt bij het backtracken. Aan deze constraint store kunnen dan constraints toegevoegd worden door zogenaamde ``tell constraints'', en opgevraagd worden met ``ask constraints''. De oorspronkelijke toestand van de constraint store is leeg, of ``true''. Een tell constraint past dan de toestand van de store aan zodat aan de opgelegde constraint voldaan wordt, en laat het programma voortlopen zolang de constraint store in een consistente staat is, zijnde (voor alle variabelen) minstens \'e\'en mogelijkheid bevat. Een ask constraint daarentegen past de toestand van de store niet aan, maar gaat alleen voort indien de gevraagde constraint door de store ge\"impliceerd wordt. Een dergelijke implicatie kan bv. gecontroleerd worden door de negatie van de gevraagde constraint toe te voegen aan de constraint store, en na te gaan of er geen inconsistentie optreedt. Indien niet, dan is de gevraagde constraint ge\"impliceerd.

Prolog kan in principe zelf ook als CLP taal gezien worden, met (in basis-Prolog) slechts \'e\'en tell constraint (\code{=}, of unificatie) en \'e\'en ask constraint (\code{==}, of controle op gelijkheid).

