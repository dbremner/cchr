\documentclass{beamer}
\usepackage{beamerthemesidebar}
\usepackage{amsmath}

\title{De Parser}
\subtitle{Compiler Constructie: Les 2}

\author{Pieter Wuille}
\date{\today}

\begin{document}

\frame{\titlepage}

\section[Overzicht]{}
\begin{frame}
  \frametitle{Overzicht}
  {\scriptsize \tableofcontents}
\end{frame}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Overzicht}
    {\scriptsize \tableofcontents[current,currentsubsection]}
  \end{frame}
}

\section{Introductie}
\subsection{Structuur}
\frame{\frametitle{Plaats in Compiler Schema}
  \begin{itemize}
  \item Source $\xrightarrow{Lex}$ Tokens
  \item {\bf Tokens $\xrightarrow{Parse}$ Reductions}
  \item Reductions $\xrightarrow{Parse Actions}$ Abstract Syntax
  \item ...
  \end{itemize}
  Parser: zet tokens om in reducties
}

\section{Van woorden naar zinnen}
\subsection{Wat we hebben}
\frame{\frametitle{Wat we hebben}
  \begin{itemize}
  \item Voorlopig hebben we ``woorden''
  \item Slechts opeenvolging van lexer tokens
  \item Geen hierarchische structuur
  \item Elk token kan op elke plaats
  \end{itemize}
  Besluit: we willen zinsstructuur bepalen
}
\subsection{Kan dat niet met lex?}
\frame{\frametitle{Kan dat niet met lex?}
  \begin{itemize}
  \item Lex staat afkortingen toe van stukjes syntax
  \item Stel: \\
    $digits$ = [0 - 9]+ \\
    $sum$ = ($digits$ ``+'')* $digits$
  \item Nu herkennen we 28+301+9 als token
  \item Maar stel: \\
    $digits$ = [0 - 9]+ \\
    $sum$ = $expr$ ``+'' $expr$ \\
    $expr$ = ``('' $sum$ ``)'' $|$ $digits$
  \item Herkennen we 28+(301+9) nu als token?
  \end{itemize}
}
\frame{\frametitle{Gebrek aan recursie}
  We hebben recursie nodig \\
  Dit vereenvoudigt de notatie ook:
  \begin{itemize}
  \item $expr$ = ab(c $|$ d)e wordt:\\
    \quad $aux$ = c \\
    \quad $aux$ = d \\
    \quad $expr$ = a b $aux$ e
  \item $expr$ = (a b c)* wordt:\\
    \quad $expr$ = (a b c) expr\\
    \quad $expr$ = $\epsilon$
  \end{itemize}
}
\frame{\frametitle{Context-Free Grammar}
  De verkregen taal heet ``Context-Free Grammar''
  \begin{itemize}
  \item Definieert syntactische structuur
  \item Flexibeler dan reguliere expressies
  \item Kunnen ook lexicale tokens definieren
  \item DFA's niet krachtig genoeg voor parsen ervan
  \end{itemize}
}
\subsection{Context-Free Grammar}
\frame{\frametitle{CFG definitie}
  CFG's worden gedefinieerd door productieregels van de vorm
  $symbool$ $\rightarrow$ $symbool$ $symbool$ $\cdots$ $symbool$.
  \begin{itemize}
  \item Symbolen zijn terminaal (TS) of niet-terminaal (NTS)
  \item Terminale symbolen zijn lexer tokens
  \item Links van $\rightarrow$ staat NTS
  \item Er is een startsymbool (NTS)
  \end{itemize}
}
\frame{\frametitle{Afleidingen}
  De taal gedefinieerd door een grammatica is de verzameling van alle opeenvolgingen van TS'en die
  afgeleid kunnen worden van het startsymbool.
  \begin{itemize}
  \item NTS worden (volgens productieregels) vervangen
  \item Men stopt als enkel TS (tokens) overblijven
  \end{itemize}
  De parse-boom onstaat door elk symbool te verbinden met hetgeen het van afgeleid is.
}
\frame{\frametitle{Ambiguiteit}
  Een grammatica wordt ambigu genoemd als eenzelfde zin (opeenvolging van tokens) meerdere
  parse-bomen kan hebben.
  \begin{itemize}
  \item Parse-trees worden gebruikt om betekenis te bepalen
  \item We willen geen zinnen met meerdere betekenissen
  \item Bv: $1-2-3$ zou $(1-2)-3$ of $1-(2-3)$ kunnen betekenen
  \end{itemize}
}

\frame{\frametitle{Ambiguiteit wegwerken}
  Een ambigue grammatica kan vaak omgezet worden in een niet-ambigue. \\
  \quad \\
  Bv.: Een ambigue taal met $+$ en $*$: \\
  \begin{tabular}{ll}
    E$\rightarrow$id  & E$\rightarrow$(E) \\
    E$\rightarrow$E+E & E$\rightarrow$E*E \\
  \end{tabular} \\
  Wordt: \\
  \begin{tabular}{lll}
    E$\rightarrow$E+T & T$\rightarrow$T*F & F$\rightarrow$id \\
    E$\rightarrow$T   & T$\rightarrow$F   & F$\rightarrow$(E) \\
  \end{tabular} \\
  \quad \\
  Een taal die niet niet-ambigu te schrijven is, is meestal niet geschikt als programmeertaal
}

\subsection{Het parsen}
\frame{\frametitle{Het parsen}
  Uiteindelijk wat de parser doet is:
  \begin{itemize}
  \item E\'en voor \'e\'en de lexer tokens (TS) opvragen
  \item Groepjes symbolen samennemen tot NTS (reducties)
  \item Deze reducties zijn de ``output'' van de parser
  \end{itemize}
}

\section{Predictive parsing}
\subsection{Eenvoudige grammatica}
\frame{\frametitle{Predictive parsing}
  De eenvoudigste grammatica's $\rightarrow$ predictive parsing
  \begin{itemize}
  \item Ook wel recursive-descent genaamd (top-down)
  \item Elk NTS wordt \'e\'en functie
  \item Elke functie beslist op basis van volgend token welke productieregel te gebruiken
  \item Dit is eigenlijk ``gokken'' welke regel te gebruiken
  \end{itemize}
}
\frame[containsverbatim]{\frametitle{Recursive descent voorbeeld}
\begin{tabular}{l l}
S$\rightarrow$if E then S else S & L$\rightarrow$end \\
S$\rightarrow$begin S L          & L$\rightarrow$; S L \\
S$\rightarrow$print E            & E$\rightarrow$num = num \\
\end{tabular} \\
\quad \\
{\tiny \begin{verbatim}
  enum token{IF, THEN, ELSE, BEGIN, PRINT, SEMI, NUM, EQ};
  extern enum token getToken(void);
  
  enum token tok;
  void advance() {tok=getToken();}
  void eat(enum token t) {if (tok==t) advance(); else error();}
  
  void S(void) {switch(tok) {
    case IF:  eat(IF); E(); eat(THEN); S(); eat(ELSE); S(); break;
    case BEGIN: eat(BEGIN); S(); L(); break;
    case PRINT: eat(PRINT); E(); break;
    default: error();
  }}
  void L(void) {switch(tok) {
    case END: eat(END); break;
    case SEMI: eat(SEMI); S(); L(); break;
    default: error();
  }
  void E(void) {switch(tok) {
    eat(NUM); eat(EQ); eat(NUM);
  }
\end{verbatim}}
}
\frame[containsverbatim]{\frametitle{Grenzen van Recursive Descent}
  We moeten op basis van het actieve NTS en het volgende token beslissen welke productie regel te gebruiken.\\
  Stel: \begin{tabular}{lll}
    S$\rightarrow$E \$ & (\$: end-of-file) & \\
    E$\rightarrow$E+T & T$\rightarrow$T*F & F$\rightarrow$num \\
    E$\rightarrow$T   & T$\rightarrow$F   & F$\rightarrow$(E) \\
  \end{tabular}
{\tiny \begin{verbatim}
  void S(void) { E(); eat(EOF); }
  void E(void) {switch(tok) {
    case ?: E(); eat(PLUS); T(); break;
    case ?: T(); break;
    default: error();
  }
  void T(void) {switch(tok) {
    case ?: T(); eat(TIMES); F(); break;
    case ?: F(); break;
    default: error();
  }
  void F(void) {...}
\end{verbatim}}
  Bv.: (1*2+3)+4 en (1*2+3). De E() functie heeft hier duidelijk geen manier om te bepalen
  bij het begin of er E$\rightarrow$E+T of gewoon E$\rightarrow$T gebruikt moet worden.
}
\subsection{First en Follow sets}
\frame{\frametitle{FIRST en FOLLOW sets}
  Om te bepalen welke tokens welke productieregel impliceren, introduceren we de FIRST en FOLLOW sets.
  \begin{itemize}
  \item FIRST set: FIRST($\gamma$) is de verzameling van alle TS die eerste teken in een zin afgeleid van $\gamma$ kunnen zijn.
  \item FOLLOW set: FOLLOW(X) is de verzameling van alle TS die in een afleiding X kunnen opvolgen.
  \end{itemize}
  Als 2 productieregels X$\rightarrow \alpha$ en X$\rightarrow \beta$ een overlappende FIRST($\alpha$) en FIRST($\beta$) hebben, kan predictive parsing niet.
}
\frame{\frametitle{Voorbeeld}
  \begin{tabular}{l l l}
    Z$\rightarrow$d & Y$\rightarrow$ & X$\rightarrow$Y \\
    Z$\rightarrow$X Y Z & Y$\rightarrow$c & X$\rightarrow$a \\
  \end{tabular} \\
  \begin{itemize}
    \item Het lijkt dat FIRST(Z) gelijk zou moeten zijn aan FIRST(X)
    \item FIRST(X) kan echter ook $\epsilon$ afleiden (het is nullable)
    \item FIRST(Y) behoort dus ook tot FIRST(Z)
  \end{itemize}
}
\frame{\frametitle{Algoritme}
  \begin{tabular}{l l l}
    Z$\rightarrow$d & Y$\rightarrow$ & X$\rightarrow$Y \\
    Z$\rightarrow$X Y Z & Y$\rightarrow$c & X$\rightarrow$a \\
  \end{tabular} \\
}
\frame{\frametitle{Uitgewerkt voorbeeld}
  \begin{tabular}{l l l}
    Z$\rightarrow$d & Y$\rightarrow$ & X$\rightarrow$Y \\
    Z$\rightarrow$X Y Z & Y$\rightarrow$c & X$\rightarrow$a \\
  \end{tabular} \\
  \quad \\
  \begin{tabular}{l|ccc}
    & nullable & FIRST & FOLLOW \\
    \hline
    X & yes & a c & a c d \\
    Y & yes & c & a c d \\
    Z & no & a c d & \\
  \end{tabular}
}
\subsection{De predictive parser}
\frame{\frametitle{Predictive Parsing Tabel}
  \begin{tabular}{l|ccc}
    & nullable & FIRST & FOLLOW \\
    \hline
    X & yes & a c & a c d \\
    Y & yes & c & a c d \\
    Z & no & a c d & \\
  \end{tabular} \\
  Hieruit kunnen we een Predictive Parsing Tabel opstellen:
  \begin{itemize}
    \item Links NTS, bovenaan TS
    \item In elk vakje de producties die ermee overeenkomen
  \end{itemize}
  \begin{tabular}{l|lll}
    & a & c & d \\
    \hline
    X & X$\rightarrow$a, X$\rightarrow$Y & X$\rightarrow$Y & X$\rightarrow$Y \\
    Y & Y$\rightarrow$ & Y$\rightarrow$, Y$\rightarrow$c & Y$\rightarrow$ \\
    Z & Z$\rightarrow$XYZ & Z$\rightarrow$XYZ & Z$\rightarrow$d, Z$\rightarrow$XYZ \\
  \end{tabular}
}
\subsection{LL(k)-grammatica}
\frame{\frametitle{LL(k)-grammatica}
  \begin{itemize}
  \item Talen die geen dubbele ingangen in de Predictive Parsing Table hebben, worden LL(1)
        genoemd.
  \item LL(k) staat voor ``Left-to-right parse, Leftmost-derivation, k-symbol lookahead''
  \item Dit wil zeggen: \begin{itemize}
    \item Left-to-right parse: het parsen gebeurt van links naar rechts
    \item Leftmost-derivation: linkse afleiding: steeds het meest linkse NTS vervangen
    \item k-symbol lookahead: beslissen welke productie gebeurt op basis van komende k tokens (hier 1).
    \end{itemize}
  \end{itemize}
}
\frame{\frametitle{Veelvoorkomende problemen}
  \begin{itemize}
  \item Linkse recursie \begin{itemize}
    \item Bv. E$\rightarrow$E+T, E$\rightarrow$T
    \item FIRST($T$) en FIRST($E+T$) overlappen zowiezo: LL(1) werkt niet
    \item Linkse recursie moet in rechtse worden omgezet
    \end{itemize}
  \item ``Left factoring'' \begin{itemize}
    \item Bv. S$\rightarrow$if E then S else S, S$\rightarrow$if E then S
    \item Twee producties voor zelfde NTS beginnen met zelfde deel
    \item Left factoring: $\rightarrow$ S$\rightarrow$if E then S X, X$\rightarrow$, X$\rightarrow$else S
    \end{itemize}
  \item Foutherstelling \begin{itemize}
    \item Voortgaan na een fout is informatiever
    \item Tokens overslaan, vervangen of invoegen
    \end{itemize}
  \end{itemize}
}
\section{LR Parsing}
\subsection{Techniek}
\frame{\frametitle{De zwakte van LL}
  LL(k) parsers zijn niet krachtig genoeg
  \begin{itemize}
  \item LL(k) parsers voorspellen welke productie te gebruiken
  \item Ze kennen enkel de k eerste tokens van de afleiding
  \item We willen die beslissing achteraf pas nemen
  \end{itemize}
  $\rightarrow$ LR(k) Parsing
  \begin{itemize}
  \item ``Left-to-right parse, {\bf Rightmost-derivation}, k-token lookahead''
  \item Left-to-right parse: we parseren van links naar rechts
  \item Rightmost-derivation: rechte afleiding: steeds het meest rechtse NTS vervangen
  \item k-symbol lookahead: k tekens vooruit kijken (zelden $>1$)
  \end{itemize}
}
\frame{\frametitle{LR(k) techniek}
  \begin{itemize}
  \item Hoe kunnen we een rechtse afleiding doen als parser links begint?
  \item Door een stack van symbolen (TS en NTS) bij te houden
  \item Op basis van de inhoud van de stack en komende symbolen: \begin{itemize}
    \item Ofwel een token uit input op stack zetten
    \item Ofwel aantal symbolen bovenop stack tot 1 NTS reduceren
    \end{itemize}
  \end{itemize}
}
\frame{\frametitle{Gebruik van DFA}
  Hoe implementeren we zo'n LR(k) parser?
  \begin{itemize}
  \item Zoals aangetoond zijn DFA's niet voldoende krachtig
  \item We kunnen DFA wel gebruiken op stack ipv input
  \item Elke ``positie'' in een productieregel is een toestand
  \item Overgangen tussen toestanden zijn symbolen (TS of NTS)
  \end{itemize}
}
\frame{\frametitle{Werking van DFA in LR parser}
  We kunnen bij elke toevoeging van een element onthouden in welke
  toestand de DFA daarmee komt, zodat niet telkens de hele stack doorlopen
  moet worden. Zie figuur 3.17 in boek. \\
  De acties in deze tabel: \begin{description}
  \item[Shift(n)] Zet volgend token met state n op stack
  \item[Reduce(k)] {\scriptsize \begin{itemize}
    \item Haal (\# symbolen in rechterkant regel k) van stack
    \item Noem X de NTS aan linkerkant van regel k
    \item Zoek in state nu bovenop stack de actie voor X
    \item Volg de ``goto b'' daar, zet X (met state n) bovenop stack
    \end{itemize}}
  \item[Accept] Shiften van \$: klaar
  \item[Error] (lege plaats) ongeldige input
  \end{description}
}
\subsection{LR(0) parsers}
\frame{\frametitle{Opstellen states en overgangstabel}
  Eerst moeten we alle states opstellen: \begin{itemize}
  \item We beginnen met de S'$\rightarrow$.S\$ state
  \item de ``.'' duidt het einde van de stack aan
  \item Volg nu volgende regels: \begin{itemize}
    \item ``.'' staat voor NTS X: voeg alle X$\rightarrow$.$\alpha$ regels toe aan state (closure)
    \item ``.'' staat voor symbool $\gamma$: maak state n met zelfde regel maar ``.'' na $\gamma$ (goto) \begin{description}
      \item[NTS] zet goto(n) in overgangstabel
      \item[TS] zet shift(n) in overgangstabel
      \end{description}
    \item ``.'' staat op einde regel k: zet reduce(k) in overgangstabel
    \item shift van \$ is een accept
    \end{itemize}
  \item Ga door tot er geen nieuwe states meer zijn.
  \end{itemize}
}
\subsection{SLR parsers}
\frame{\frametitle{Shift-Reduce conflicten}
  Stel we proberen een LR(0) parser voor deze grammatica:
  \begin{tabular}{ll}
    S$\rightarrow$E\$ & E$\rightarrow$T \\
    E$\rightarrow$T+E & T$\rightarrow$x \\
  \end{tabular}
  \quad \\
  $\rightarrow$ toestand ``E$\rightarrow$T.+E'' en ``E$\rightarrow$T.'' als regels.
  $\rightarrow$ Als er ``+'' volgt, moet zowel een shift als een reduce gebeuren. \\
  Dit heet een {\bf shift-reduce conflict}. \\
  $\rightarrow$ Deze grammatica is niet LR(0). \\
  $\rightarrow$ We hebben iets krachtiger nodig
}
\frame{\frametitle{SLR Parser generatie}
  \begin{tabular}{ll}
    S$\rightarrow$E\$ & E$\rightarrow$T \\
    E$\rightarrow$T+E & T$\rightarrow$x \\
  \end{tabular}
  \quad \\
  \begin{itemize}
  \item LR(0) zet reduce op elk token in tabel
  \item Beter: enkel bij tokens uit FOLLOW(A) (bij A$\rightarrow \alpha$ regel) $\rightarrow$ minder Shift-Reduce conflicten (wegens minder Reduce's)
  \item Dit heet SLR (Simple LR)
  \item Bovenstaande grammatica is SLR
  \item SLR is krachtiger dan LR(0)
  \end{itemize}
}
\subsection{LR(1) parsers}
\frame{\frametitle{Nog krachtiger dan SLR}
  SLR vermijdt een deel overbodige reduce's, maar echt reduce's laten afhangen van volgend token kan niet.
  $\rightarrow$ LR(1) parsers \begin{itemize}
  \item In toestandstabellen wordt extra volgend token opgenomen (niet na \$)
  \item Toestanden zijn verschillend als volgend token verschilt
  \item Reduce acties worden enkel geplaatst bij die volgende tokens.
  \end{itemize}
  $\rightarrow$ zeer veel toestanden
}
\frame{\frametitle{LALR(1) parsers}
  Omdat LR(1) tables heel groot kunnen worden, voert men een vereenvoudiging door: \begin{itemize}
  \item Toestanden die op volgend token na identiek zijn worden samengenomen
  \item De bekomen parser heet LALR(1) (Look-Ahead LR(1))
  \item LALR(1) is krachtiger dan SLR (een SLR taal is ook LALR(1))
  \item LALR(1) is wel zwakker dan LR(1)
  \item Bijna alle praktische talen zijn LALR(1)
  \end{itemize}
  $\rightarrow$ er zijn veel LALR(1) parser generators beschikbaar (yacc, bison)
}
\frame{\frametitle{Ambiguiteit en Shift-Reduce conflicten}
  \begin{itemize}
  \item Stel een grammatica als: ``S$\rightarrow$if E then S else S'', ``S$\rightarrow$if E then S''.
  \item Dit laat zinnen als ``if a then if b then s1 else s2'' toe
  \item Er zijn 2 interpretaties: \begin{itemize}
    \item if a then \{ if b then s1 else s2 \}
    \item if a then \{ if b then s1 \} else s2
    \end{itemize}
  \item Dit wordt een shift-reduce conflict in een LR parse table
  \item We kunnen kiezen om toch te shiften, door voor het eerste te kiezen
  \item Dit is gevaarlijk, maar laat toe ambigue talen te parsen
  \end{itemize}
}
\section{Parser generators}
\subsection{YACC}
\frame{\frametitle{YACC}
  Het genereren van LR(1) (en vooral LALR(1)) parse tables kan geautomatiseerd worden.
  
  De traditionale applicatie hiervoor is YACC (Yet Another Compiler-Compiler), \\
  maar er zijn modernere implementaties zoals Bison. \\
  Werking: \begin{itemize}
  \item Neemt als input een ``grammar file''
  \item LALR(1) parse table wordt opgesteld
  \item Parse table + LALR(1) parse algoritme $\rightarrow$ C code 
  \item Code bevat functie yyparse() \begin{itemize}
    \item roept functie yylex() aan om de tokens te verkrijgen
    \item roept functie yyerror() aan bij een fout
    \item voert acties uit grammar file uit bij elke reductie
    \end{itemize}
  \end{itemize}
}
\frame{\frametitle{YACC grammar}
  De syntax van YACC grammar files:
  \begin{itemize}
  \item Eerst een specifieke header voor declaratie yylex() en yyparse()
  \item Vernoeming alle lexer tokens (TS)
  \item Vernoemen startsymbool
  \item Eventueel wat opties zoals voorrangsregels
  \item Dan een lijst met alle productieregels
  \end{itemize}
  (zie voorbeeld)
}
\subsection{Conflicten}
\frame{\frametitle{YACC en conflicten}
  \begin{itemize}
  \item YACC detecteert shift-reduce en reduce-reduce conflicten
  \item Standaard is dit geen error, maar wordt dit gedaan: \begin{itemize}
    \item Bij Shift-Reduce conflicten wordt shift gekozen
    \item Bij Reduce-Reduce conflicten wordt eerst vermeldde regel gekozen
    \end{itemize}
  \item Er kunnen prioriteitsregels gegeven worden om dit gedrag te veranderen
  \end{itemize}
  (zie voorbeeld)
}
\subsection{Voor volgende week}
\frame{\frametitle{Semantiek is voor volgende week}
  Men kan geneigd zijn een parser teveel te laten doen:
  \begin{itemize}
  \item De parser moet enkel de structuur van de zinnen achterhalen
  \item Niet alle operatoren mogen misschien op alle argumenten
  \item Zaken als data-types horen niet thuis in de grammatica
  \end{itemize}
  $\rightarrow$ Deze dingen worden in de semantische analyse gedaan
}
\frame{\frametitle{THE END}
  \begin{center} {\huge EINDE} \end{center}
}
\end{document}
