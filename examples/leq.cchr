#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "logical.h"
#include "leq_cchr.h"

#ifdef USE_EFENCE
#include <efence.h>
#endif

typedef struct {
  cchr_htdc_t leq_2_arg1;
  cchr_htdc_t leq_2_arg2;
  cchr_htdc_t leq_2_ra;
} log_int_t_tag_t;

logical_header(int,log_int_t_tag_t,log_int_t)

#define log_int_t_reactivate(var) { \
  CSM_DECLOGUNILOOP(RA,CSM_CB_FFVDC,) \
  CSM_LOGUNILOOP(leq_2,RA,local,leq_2_ra,log_int_t,var,{cchr_reactivate_leq_2(CSM_PID(RA,local));}) \
}

#define log_int_cb_created(val) { \
  cchr_htdc_t_init(&(log_int_t_getextrap(val)->leq_2_arg1)); \
  cchr_htdc_t_init(&(log_int_t_getextrap(val)->leq_2_arg2)); \
  cchr_htdc_t_init(&(log_int_t_getextrap(val)->leq_2_ra)); \
}
#define log_int_cb_merged(val1,val2) { \
  cchr_htdc_t_addall(&(log_int_t_getextrap(val1)->leq_2_arg1),&(log_int_t_getextrap(val2)->leq_2_arg1)); \
  cchr_htdc_t_addall(&(log_int_t_getextrap(val1)->leq_2_arg2),&(log_int_t_getextrap(val2)->leq_2_arg2)); \
  cchr_htdc_t_addall(&(log_int_t_getextrap(val1)->leq_2_ra),&(log_int_t_getextrap(val2)->leq_2_ra)); \
}
#define log_int_cb_changed(val) { \
  log_int_t_reactivate(val); \
}
#define log_int_cb_destrval(val)
#define log_int_cb_destrtag(val) { \
  cchr_htdc_t_free(&(log_int_t_getextrap(val)->leq_2_arg1)); \
  cchr_htdc_t_free(&(log_int_t_getextrap(val)->leq_2_arg2)); \
  cchr_htdc_t_free(&(log_int_t_getextrap(val)->leq_2_ra)); \
}


cchr {
  constraint leq(log_int_t,log_int_t) 
    option(init,{log_int_t_copy($1);log_int_t_copy($2);})
    option(destr,{log_int_t_destruct($1);log_int_t_destruct($2);}) 
    option(fmt,"leq""(#%i,#%i)""[%p,%p]" ,log_int_t_normalize($1)->_id,log_int_t_normalize($2)->_id ,$1,$2)
    option(add,{
      cchr_id_t pid=$0;
      int id=CSM_IDOFPID($0);
      cchr_htdc_t_set(&(log_int_t_getextrap($1)->leq_2_arg1),&id,&pid);
      cchr_htdc_t_set(&(log_int_t_getextrap($2)->leq_2_arg2),&id,&pid);
      cchr_htdc_t_set(&(log_int_t_getextrap($1)->leq_2_ra),&id,&pid);
      cchr_htdc_t_set(&(log_int_t_getextrap($2)->leq_2_ra),&id,&pid);
    })
    option(kill,{
      int id=CSM_IDOFPID($0);
      cchr_htdc_t_unset(&(log_int_t_getextrap($1)->leq_2_arg1),&id);
      cchr_htdc_t_unset(&(log_int_t_getextrap($2)->leq_2_arg2),&id);
      cchr_htdc_t_unset(&(log_int_t_getextrap($1)->leq_2_ra),&id);
      cchr_htdc_t_unset(&(log_int_t_getextrap($2)->leq_2_ra),&id);
    })
    ;
  
  extern eq;
  
  logical log_int_t log_int_cb;
  chr_macro eq(log_int_t,log_int_t) log_int_t_testeq($1,$2);
  
  reflexivity @ leq(X,Y) <=> eq(X,Y) | true;
  antisymmetry @ leq(X1,Y1), leq(Y2,X2) <=> eq(X1,X2),eq(Y1,Y2) | {log_int_t_seteq(X1,Y1);};
  idempotence @ leq(X1,Y1) \ leq(X2,Y2) <=> eq(X1,X2),eq(Y1,Y2) | true;
  transitivity @ leq(X,Y1), leq(Y2,Z) ==> eq(Y1,Y2) | leq(X,Z);
}

logical_code(int,log_int_t_tag_t,log_int_t,log_int_cb)

void test(int size) {
  cchr_runtime_init();
  log_int_t *vars=malloc(sizeof(log_int_t)*size);
  for (int j=0; j<size; j++) {vars[j]=log_int_t_create(); log_int_t_setval(vars[j],j+1);}
  for (int j=0; j<size; j++) cchr_add_leq_2(vars[j],vars[(j+1)%size]);
  fprintf(stderr,"done!\n");
  int aj=0;
  /* following line still causes some problems ... not all constraints get removed */
  cchr_consloop(j,leq_2,{fprintf(stderr,"outch %i (%i,%i)!\n",aj++,log_int_t_getval(cchr_consarg(j,leq_2,1)),log_int_t_getval(cchr_consarg(j,leq_2,2)));}); 
  for (int j=0; j<size; j++) {
    if (!log_int_t_testeq(vars[j],vars[(j+1)%size])) fprintf(stderr,"noteq %i %i\n",j,j+1);
  }
  cchr_runtime_free();
  for (int j=0; j<size; j++) log_int_t_destruct(vars[j]);
  free(vars);
}


int main(int argc, char** argv) {
  int n=argc>1 ? strtol(argv[1],NULL,0) : 100;
  test(n);
  return 0;
}
