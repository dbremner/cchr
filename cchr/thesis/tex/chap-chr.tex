\chapter{Constraint Handling Rules}

In dit hoofdstuk wordt een overzicht gegeven van de taal CHR.

\section{Inleiding}

De eerste constraint solvers volgden het zogenaamde {\em black box} principe: men kon constraints opgeven en de constraint solver, die specifiek voor de gebruikte constraints over een vastgesteld domein gemaakt was, lostte ze op. Hierbij was het nauwelijks mogelijk om inzicht te krijgen hoe de constraint solvers zelf werkten, en zeker moeilijk of onmogelijk om er aanpassingen aan te maken. Men had echter nood aan constraint solvers die specifiek voor een bepaalde applicaties problemen konden oplossen. In een volgende geneneratie solvers, werd dit probleem opgelost door meer controle over de solver in handen van de programmeur te leggen. De gebruikte zogenaamde  {\em glass box} technieken en evolutie wordt uitgelegd in \cite{chr}. Hierin haalt men ook de {\em no box} strategie aan: de werking van de constraint solver ligt volledig in handen van de programmeur.

CHR is een hoog-niveau, declaratieve taaluitbreiding voor C(L)P. Het geeft de mogelijkheid om in een gegeven host-taal die reeds enkele {\em built-in constraints} ondersteunt, nieuwe door de gebruiker gedefini\"eerde constraints ({\em CHR constraints} genaamd) te gaan toevoegen. CHR geeft dan een mogelijkheid te specifi\"eren hoe deze CHR constraints, die door een CHR programma aan de host-taal toegevoegd kunnen worden, omgezet worden in verschillende stappen tot nieuwe CHR constraints, en built-in constraints. In wezen bestaat de uitvoering van een CHR programma uit een herhaaldelijke toepassing van transformatie-regels die op de gegeven constraints uitgevoerd worden tot ze opgelost zijn.

CHR staat voor Constraint Handling Rules, en een CHR programma bestaat uit een opsomming van regels die beschrijven hoe en wanneer CHR constraints herschreven mogen worden tot andere constraints. We zullen hier een beschrijving geven van CHR in te bedden in Prolog, wat gebruikelijk is. Op die manier kan de CHR syntax en semantiek het gemakkelijkst beschreven worden. Bij het inbedden van CHR in een imperatieve taal zijn vaak enkele omwegen nodig om de hosttaal als C(L)P taal te kunnen gebruiken. De built-in constraints die Prolog aanbiedt zijn zijn \code{=} (unificatie), \code{==} (termgelijkheid), gebruiker-gedefinieerde predikaten en enkele ingebouwde predikaten.

\section{Syntax}

Constraints nemen de vorm aan van predikaten, met een naam en een ariteit. Ze moeten op een of andere manier gedeclareerd worden als constraint, in plaats van normaal predikaat. In Prolog CHR gebeurt dat met: \begin{Verbatim}
  :- chr_constraint upto(+int),prime(+int).
\end{Verbatim}
Hiermee wordt duidelijk gemaakt dat \code{upto/1} en \code{prime/1} geen predikaten maar constraints zijn.

Vervolgens moeten de CHR rules gegeven worden. Deze beschrijven hoe gebruikers-gedefinieerde constraints omgezet moeten worden naar built-in constraint en andere CHR constraints. Constraints zijn hierbij een enkelvoudige constraint, of een conjunctie van verschillende constraints gescheiden door kommas. Een lege conjunctie van constraints wordt voorgesteld door het sleutelwoord {\em true}. 

Er zijn drie types van CHR rules: \begin{itemize}
\item Simplification: \code{$naam$ @ $r$ <=> $g$ | $b$ .}
\item Propagation: \code{$naam$ @ $k$ ==> $g$ | $b$ .}
\item Simpagation: \code{$naam$ @ $k$ $\backslash$ $r$ <=> $g$ | $b$ .}
\end{itemize}
Elke rule begint met een $ naam @ $ prefix, om de naam van de regel aan te duiden. Dit is optioneel. Vervolgens worden enkele constraints met variabelen als argumenten vermeld. $r$ en $k$, de {\em removed} en {\em kept} constraints, worden samen de {\em head} van de CHR rule genoemd. Dit zijn de constraints die aanwezig moeten zijn in de CHR constraint store vooraleer de rule toegepast kan worden. De head kan enkel CHR constraints bevatten, en geen built-in constraints. Daarna volgt een scheidingsteken (\code{<=>} of \code{==>}) om het einde van de head aan te duiden. Vervolgens is er een optionele \code{$g$ |}, de guard genaamd. De guard dient om een voorwaarde op te geven waaraan de argumenten van de head constraints moeten voldoen. De guard mag enkel built-in constraints bevatten. Indien deze weggelaten wordt, wordt true verondersteld. Het laatste deel van een CHR rule is de {\em body} $b$, afgesloten met een punt. Dit beschrijft de constraints die toegevoegd moeten worden wanneer de regel uitgevoerd wordt. Dit mag zowel built-in als CHR constraints beschrijven.

Een simpagation rule met $k$ leeg is equivalent met een simplification rule, en een simpagation rule met $r$ leeg is equivalent met een propagation rule. Daarom kunnen simpagation rules gezien worden als de veralgemening van beide vorige types. In wat volgt zullen alle regels dan ook beschouwd worden als veralgemeende simpagation rules, met eventueel $r$ of $k$ leeg. De logische betekenis van een dergelijke CHR regel is dat op voorwaarde dat voor elke combinatie van de CHR constraints vermeld in $k$ en $r$ er geldt dat op voorwaarde dat $g$ geldt, $r$ equivalent is $b$.

Een voorbeeldje:
\begin{Verbatim}
  simplification @ upto(X) <=> X<2 | true.
  propagation @ upto(X) ==> X>1 | Y is X-1, upto(Y), prime(X).
  simpagation @ prime(X) \ prime(Y) <=> Z is Y mod X, Z==0 | true.
\end{Verbatim}

De eerste regel stelt dat wanneer een \code{upto/1} constraint aanwezig is, en het argument daarvan kleiner is dan $2$, deze constraint verwijderd mag worden. De tweede regel stelt dat een \code{upto/1} vervangen moet worden door een \code{prime/1} constraint met hetzelfde argument, en een \code{upto/1} constraint met zijn argument verlaagd met $1$. De laatste regel stelt dat een \code{prime/1} verwijderd mag worden als zijn argument een veelvoud is van het argument van een andere \code{prime/1} constraint.

\section{Operationele semantiek}

In deze sectie wordt de semantiek van CHR besproken. Er zijn meerdere verschillende semantieken gedefinieerd, en we zullen hier eerst de $\omega_t$ of theoretische operationele semantiek aanhalen, en vervolgens de $\omega_r$ of verfijnde operationele semantiek. Beiden zijn rigoreus beschreven in \cite{refined}.

\subsection{De theoretische operationele semantiek $\omega_t$}

De theoretische operationele semantiek beschrijft het uitvoeren van CHR als een aantal mogelijke overgangen van een toestandsmachine. De toestand bestaat uit: \begin{itemize}
\item Een doel, of {\em goal} $G$. Dit is een verzameling CHR constraints die nog toegevoegd moeten worden aan de constraint store. Het is initi\"eel de CHR constraints van het probleem dat men wenst op te lossen.
\item Een CHR constraint store $S$, een multiset met ge\"identificeerde CHR constraints. Een ge\"identificeerde CHR constraint is een constraint die een uniek volgnummer toegewezen heeft gekregen. Dit is noodzakelijk om constraints die meermaals in de constraint store voorkomen te kunnen onderscheiden. Het is initi\"eel de lege verzameling.
\item Een built-in constraint store $B$. De host-taal heeft controle over deze constraint store, dus ze wordt hier beschouwd als een ondoorzicht object, waaraan tell constraints aan opgelegd kunnen worden, en ask constraints aan opgevraagd. Dit is initi\"eel {\em true}
\item Een propagation history $T$. Deze dient om bij te houden welke regels reeds toegepast zijn op de CHR constraint store, zodat deze geen tweede maal toegepast worden. Dit begint als de lege lijst. 
\item Een constraint-teller $n$. Dit start op 1.
\end{itemize}

Nu worden er 3 overgangen gedefinieerd: \begin{itemize}
\item {\bf Solve} Bij deze overgang wordt een (built-in) constraint die in de goal $G$ aanwezig is daaruit verwijderd en aan de built-in constraint store $B$ toegevoegd. 
\item {\bf Introduce} Bij deze overgang wordt een CHR constraint uit de goal $G$ verwijderd en als ge\"identificeerde CHR constraint aan de CHR constraint store $S$ toegevoegd. Deze krijgt hierbij als volgnummer de waarde van de constraint-teller $n$, en de constraint-teller $n$ wordt vervolgens verhoogd.
\item {\bf Apply} Wanneer alle constraints die aanwezig zijn in de head van een CHR rule aanwezig zijn, en de argumenten ervan aan de bijhorende guard voldoen, kunnen de removed constraints daarvan verwijderd worden uit de store $S$, en de body constraints toegevoegd worden aan de goal $G$. Hierbij worden ook de volgnummers van de betrokken ge\"identificeerde constraints toegevoegd als item aan de propagation history $T$, en wordt ge\"eist dat deze combinatie nog niet bestond in de propagation history.
\end{itemize}

Deze overgangen worden toegepast in arbitraire volgorde, zolang er minstens \'e\'en toepasbaar is. De uitvoering stopt zodra er ofwel geen overgangen meer kunnen plaats vinden, wat optreedt nadat de goal $G$ leeg is, en er geen CHR rules meer toegepast kunnen worden. Wanneer de CHR constraint store leeg is en alle constraints in de originele goal dus herleid zijn tot built-in constraints zijn er sowieso geen regels meer toepasbaar. De uitvoering stopt ook wanneer de built-in constraint store een inconsistentie opmerkt. In dat geval eindigt de CHR uitvoering als ``gefaald''.

Over deze semantiek $\omega_t$ zijn verschillende theoretische eigenschappen bekend, zoals wanneer de volgorde waarin de overgangen toegepast worden irrelevant is (confluentie), en tijdscomplexiteit. Hier wordt uitgebreid op in gegaan in \cite{tomsphdthesis}.

\subsection{De verfijnde operationele semantiek $\omega_r$}

Het probleem met de theoretische operationele semantiek $\omega_t$ is dat ze vrij veel ongedefinieerd laat. De $\omega_r$ verfijnde operationele semantiek lost dit probleem op door meer vast te leggen. Dit betekent dat $\omega_r$ een instantie is van $\omega_t$. Dat elke uitvoering volgens $\omega_r$ afgebeeld kan worden op een $\omega_t$ uitvoering is aangetoond in \cite{refined}.

Abstract wordt de $\omega_r$ operationele semantiek gelijkaardig aan $\omega_t$ gedefinieerd als mogelijke overgangen tussen toestanden. De toestand is dezelfde als deze van de $\omega_t$ semantiek, echter met een stapel (stack) in plaats van een verzameling als goal. Deze wordt dan ook de activatiestapel $A$ genoemd. De constraint die zich op de top van de stapel bevindt, wordt de actieve constraint genoemd, en eerst verwerkt.

Het algoritme begint met een lege CHR constraint store $S$, lege built-in constraint store $B$, en lege history $T$. Als initi\"ele stack worden de verschillende constraints van het probleem genomen. Merk op dat in een stapel de volgorde van belang is. Vanaf dan wordt telkens de actieve constraint beschouwd. Er zijn nu twee mogelijkheden: \begin{itemize}
\item Als het een built-in constraint is, wordt deze verwijderd en aan de built-in constraint store toegevoegd. Hierbij worden eveneens CHR constraints die zich reeds in de CHR constraint store $S$ bevinden en eventueel betrokken kunnen worden in een CHR rule nu de toestand van de built-in constraint store gewijzigd is, terug bovenop de activatiestapel gezet. Dit heet {\em reactivatie}.
\item Als het een CHR constraint is, krijgt deze een volgnummer zoals in de theoretische semantiek $\omega_t$. Ze wordt echter nog niet van de activiatiestapel verwijderd. Eerst wordt voor de actieve constraint gezocht naar partner constraints, in de volgorde dat de betrokken constraint voorkomt in regels in het bronprogramma. Deze voorkomens in de regels worden occurrences genoemd. In de $\omega_r$ semantiek is de volgorde van regels dus van belang. Zodra er partner constraints gevonden worden in de constraint store $S$, voor een specifieke CHR rule waarvan de guard voldaan is, wordt deze toegepast. Dit wilt zeggen: de removed constraints worden uit de CHR constraint store $S$ verwijderd, en indien de actieve constraint een removed constraint was, wordt deze eveneens van de activatiestapel verwijderd. Vervolgens wordt de body van de regel vooraan de activatiestapel toegevoegd. De volgnummers van de betrokken ge\"identificeerde constraints in de CHR store worden ook toegevoegd aan de propagation history. Wanneer de body van de betrokken regel niet leeg was, komen hierbij nieuwe constraints op de activatiestapel te staan, en zullen deze eerst afgewerkt worden vooraleer de verwerking van de origineel betrokken constraint voortgaat. Wanneer deze verwerking van door de body toegevoegde constraints afgelopen is, en alle mogelijke occurrences geprobeerd zijn, wordt de regel van de activatiestapel verwijderd.
\end{itemize}
Het algoritme eindigt wanneer ofwel de built-in constraint store $B$ in een inconsistentie toestand terechtkomt, of wanneer de activatiestapel leeg is.
