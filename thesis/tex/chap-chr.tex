\chapter{Constraint Handling Rules}

In dit hoofdstuk wordt een overzicht gegeven van de taal CHR.

\section{Inleiding}

De eerste constraint solvers volgden het zogenaamde {\em black box} principe: men kon constraints opgeven en de constraint solver, die specifiek voor de gebruikte constraints over een vastgesteld domein gemaakt was, lostte ze op. Hierbij was het nauwelijks mogelijk om inzicht te krijgen hoe de constraint solvers zelf werkten, en zeker moeilijk of onmogelijk om er aanpassingen aan te maken. Men had echter nood aan constraint solvers die specifiek voor een bepaalde applicaties problemen konden oplossen. In een volgende geneneratie solvers, werd dit probleem opgelost door meer controle over de solver in handen van de programmeur te leggen. De gebruikte zogenaamde  {\em glass box} technieken en evolutie wordt uitgelegd in \cite{chr}. Hierin haalt men ook de {\em no box} strategie aan: de werking van de constraint solver ligt volledig in handen van de programmeur.

CHR is een hoog-niveau, declaratieve taaluitbreiding voor C(L)P. Het geeft de mogelijkheid om in een gegeven host-taal die reeds enkele {\em built-in constraints} ondersteunt, nieuwe door de gebruiker gedefini\"eerde constraints ({\em CHR constraints} genaamd) te gaan toevoegen. CHR geeft dan een mogelijkheid te specifi\"eren hoe deze CHR constraints, die door een CHR programma aan de host-taal toegevoegd kunnen worden, omgezet worden in verschillende stappen tot nieuwe CHR constraints, en built-in constraints. In wezen bestaat de uitvoering van een CHR programma uit een herhaaldelijke toepassing van transformatie-regels die op de gegeven constraints uitgevoerd worden tot ze opgelost zijn.

CHR staat voor Constraint Handling Rules, en een CHR programma bestaat uit een opsomming van regels die beschrijven hoe en wanneer CHR constraints herschreven mogen worden tot andere constraints. We zullen hier een beschrijving geven van CHR in te bedden in Prolog, wat gebruikelijk is. Op die manier kan de CHR syntax en semantiek het gemakkelijkst beschreven worden. Bij het inbedden van CHR in een imperatieve taal zijn vaak enkele omwegen nodig om de hosttaal als C(L)P taal te kunnen gebruiken. De built-in constraints die Prolog aanbiedt zijn zijn \code{=} (unificatie), \code{==} (termgelijkheid), gebruiker-gedefinieerde predikaten en enkele ingebouwde predikaten.

\section{Syntax} \label{sec:chr-syntax}

Een CHR programma zal normaal beginnen met een manier om de declareren welke namen overeenkomen met CHR constraints, en eventueel parameters erover instellen. Dit is afhankelijk van taal tot taal, en wordt hier niet behandeld.

Vervolgens moeten de CHR rules gegeven worden. Deze beschrijven hoe gebruikers-gedefinieerde constraints omgezet moeten worden naar built-in constraint en andere CHR constraints. Constraints zijn hierbij een enkelvoudige constraint, of een conjunctie van verschillende constraints gescheiden door kommas. Een lege conjunctie van constraints wordt voorgesteld door het sleutelwoord {\em true}. 

Er zijn drie types van CHR rules: \begin{itemize}
\item Simplification: \code{$naam$ @ $r$ <=> $g$ | $b$ .}
\item Propagation: \code{$naam$ @ $k$ ==> $g$ | $b$ .}
\item Simpagation: \code{$naam$ @ $k$ $\backslash$ $r$ <=> $g$ | $b$ .}
\end{itemize}
Elke rule begint met een $ naam @ $ prefix, om de naam van de regel aan te duiden. Dit is optioneel. Vervolgens worden enkele constraints met variabelen als argumenten vermeld. $r$ en $k$, de {\em removed} en {\em kept} constraints, worden samen de {\em head} van de CHR rule genoemd. Dit zijn de constraints die aanwezig moeten zijn in de CHR constraint store vooraleer de rule toegepast kan worden. De head kan enkel CHR constraints bevatten, en geen built-in constraints. Daarna volgt een scheidingsteken (\code{<=>} of \code{==>}) om het einde van de head aan te duiden. Vervolgens is er een optionele \code{$g$ |}, de guard genaamd. De guard dient om een voorwaarde op te geven waaraan de argumenten van de head constraints moeten voldoen. De guard mag enkel built-in constraints bevatten. Indien deze weggelaten wordt, wordt true verondersteld. Het laatste deel van een CHR rule is de {\em body} $b$, afgesloten met een punt. Dit beschrijft de constraints die toegevoegd moeten worden wanneer de regel uitgevoerd wordt. Dit mag zowel built-in als CHR constraints beschrijven.

Een simpagation rule met $k$ leeg is equivalent met een simplification rule, en een simpagation rule met $r$ leeg is equivalent met een propagation rule. Daarom kunnen simpagation rules gezien worden als de veralgemening van beide vorige types. In wat volgt zullen alle regels dan ook beschouwd worden als veralgemeende simpagation rules, met eventueel $r$ of $k$ leeg. De logische betekenis van een dergelijke CHR regel is dat op voorwaarde dat voor elke combinatie van de CHR constraints vermeld in $k$ en $r$ er geldt dat op voorwaarde dat $g$ geldt, $r$ equivalent is $b$.

Een voorbeeldje is te vinden in codevoorbeeld~\ref{code:primes-prolog}
\begin{exCode}[bp]
\begin{Verbatim}[frame=single]
  simplification @ upto(X) <=> X<2 | true.
  propagation @ upto(X) ==> X>1 | Y is X-1, upto(Y), prime(X).
  simpagation @ prime(X) \ prime(Y) <=> Z is Y mod X, Z==0 | true.
\end{Verbatim}
\caption{Priemgetallen in Prolog-CHR}
\label{code:primes-prolog}
\end{exCode}
De eerste regel stelt dat wanneer een \code{upto/1} constraint aanwezig is, en het argument daarvan kleiner is dan $2$, deze constraint verwijderd mag worden. De tweede regel stelt dat een \code{upto/1} vervangen moet worden door een \code{prime/1} constraint met hetzelfde argument, en een \code{upto/1} constraint met zijn argument verlaagd met $1$. De laatste regel stelt dat een \code{prime/1} verwijderd mag worden als zijn argument een veelvoud is van het argument van een andere \code{prime/1} constraint.

\section{Operationele semantiek}

In deze sectie wordt de semantiek van CHR besproken. Er zijn meerdere verschillende semantieken gedefinieerd, en we zullen hier eerst de $\omega_t$ of theoretische operationele semantiek aanhalen, en vervolgens de $\omega_r$ of verfijnde operationele semantiek. Beiden zijn rigoreus beschreven in \cite{refined}.

\subsection{De theoretische operationele semantiek $\omega_t$}

De theoretische operationele semantiek beschrijft het uitvoeren van CHR als een aantal mogelijke overgangen van een toestandsmachine. De toestand bestaat uit: \begin{itemize}
\item Een doel, of {\em goal} $G$. Dit is een verzameling CHR constraints die nog toegevoegd moeten worden aan de constraint store. Het is initi\"eel de CHR constraints van het probleem dat men wenst op te lossen.
\item Een CHR constraint store $S$, een multiset met ge\"identificeerde CHR constraints. Een ge\"identificeerde CHR constraint is een constraint die een uniek volgnummer toegewezen heeft gekregen. Dit is noodzakelijk om constraints die meermaals in de constraint store voorkomen te kunnen onderscheiden. Het is initi\"eel de lege verzameling.
\item Een built-in constraint store $B$. De host-taal heeft controle over deze constraint store, dus ze wordt hier beschouwd als een ondoorzicht object, waaraan tell constraints aan opgelegd kunnen worden, en ask constraints aan opgevraagd. Dit is initi\"eel {\em true}
\item Een propagation history $T$. Deze dient om bij te houden welke regels reeds toegepast zijn op de CHR constraint store, zodat deze geen tweede maal toegepast worden. Dit begint als de lege lijst. 
\item Een constraint-teller $n$. Dit start op 1.
\end{itemize}

Nu worden er 3 overgangen gedefinieerd: \begin{itemize}
\item {\bf Solve} Bij deze overgang wordt een (built-in) constraint die in de goal $G$ aanwezig is daaruit verwijderd en aan de built-in constraint store $B$ toegevoegd. 
\item {\bf Introduce} Bij deze overgang wordt een CHR constraint uit de goal $G$ verwijderd en als ge\"identificeerde CHR constraint aan de CHR constraint store $S$ toegevoegd. Deze krijgt hierbij als volgnummer de waarde van de constraint-teller $n$, en de constraint-teller $n$ wordt vervolgens verhoogd.
\item {\bf Apply} Wanneer alle constraints die aanwezig zijn in de head van een CHR rule aanwezig zijn, en de argumenten ervan aan de bijhorende guard voldoen, kunnen de removed constraints daarvan verwijderd worden uit de store $S$, en de body constraints toegevoegd worden aan de goal $G$. Hierbij worden ook de volgnummers van de betrokken ge\"identificeerde constraints toegevoegd als item aan de propagation history $T$, en wordt ge\"eist dat deze combinatie nog niet bestond in de propagation history.
\end{itemize}

Deze overgangen worden toegepast in arbitraire volgorde, zolang er minstens \'e\'en toepasbaar is. De uitvoering stopt zodra er ofwel geen overgangen meer kunnen plaats vinden, wat optreedt nadat de goal $G$ leeg is, en er geen CHR rules meer toegepast kunnen worden. Wanneer de CHR constraint store leeg is en alle constraints in de originele goal dus herleid zijn tot built-in constraints zijn er sowieso geen regels meer toepasbaar. De uitvoering stopt ook wanneer de built-in constraint store een inconsistentie opmerkt. In dat geval eindigt de CHR uitvoering als ``gefaald''.

Over deze semantiek $\omega_t$ zijn verschillende theoretische eigenschappen bekend, zoals wanneer de volgorde waarin de overgangen toegepast worden irrelevant is (confluentie), en tijdscomplexiteit. Hier wordt uitgebreid op in gegaan in \cite{tomsphdthesis}.

\subsection{De verfijnde operationele semantiek $\omega_r$}

Het probleem met de theoretische operationele semantiek $\omega_t$ is dat ze vrij veel ongedefinieerd laat. Ze is wat men noemt {\em indeterministisch}. De $\omega_r$ verfijnde operationele semantiek lost dit probleem op door meer vast te leggen. Elke uitvoering volgens $\omega_r$ blijft wel te beschouwen als een $\omega_t$ uitvoering. Dit betekent dat $\omega_r$ een instantie is van $\omega_t$. 

Het uitvoeringsmechanisme is gelijkaardig aan dat van de $\omega_t$ semantiek, maar er wordt gebruik gemaakt van een stapel te verwerken constraints in plaats van een verzameling. Deze wordt de activatiestapel $A$ genoemd. Het algoritme begint met een lege CHR constraint store $S$, lege built-in constraint store $B$, en lege history $T$. Als initi\"ele stack worden de verschillende constraints van het probleem genomen. Merk op dat in een stapel de volgorde van belang is. Vanaf dan wordt telkens de actieve constraint beschouwd. De formele defintie van de overgangen en hoe ze toegepast worden is te vinden in \cite{tomsphdthesis}. Hier wordt enkel een informeel overizcht van het uitvoeringsmechanisme gegeven, waarbij de toestandsovergangen in het vet vermeld zijn.

Er zijn nu twee mogelijkheden: \begin{itemize}
\item Als de actieve constraint een built-in constraint is, wordt deze verwijderd en aan de built-in constraint store toegevoegd ({\bf Solve}). Hierbij worden eveneens CHR constraints die zich reeds in de CHR constraint store $S$ bevinden en eventueel betrokken kunnen worden in een CHR rule nu de toestand van de built-in constraint store gewijzigd is, terug bovenop de activatiestapel gezet ({\bf Reactivate}).
\item Als de actieve constraint een CHR constraint is, krijgt deze een volgnummer zoals in de theoretische semantiek $\omega_t$ en wordt ze in de CHR constraint store geplaatst ({\bf Activate}). Ze wordt echter nog niet van de activiatiestapel verwijderd. Eerst wordt voor de actieve constraint gezocht naar partner constraints, in de volgorde dat de betrokken constraint voorkomt in regels in het bronprogramma. Deze voorkomens in de regels worden occurrences genoemd. In de $\omega_r$ semantiek is de volgorde van regels dus van belang. Zodra er partner constraints gevonden worden in de constraint store $S$, voor een specifieke CHR rule waarvan de guard voldaan is en de betrokken combinatie van ge\"identificeerde constraints zich nog niet in de propagation history bevindt, wordt deze toegepast ({\bf Simplify} of {\bf Propagate}). Dit wilt zeggen: de removed constraints worden uit de CHR constraint store $S$ verwijderd, en indien de actieve constraint een removed constraint was, wordt deze eveneens van de activatiestapel verwijderd. Vervolgens wordt de body van de regel vooraan de activatiestapel toegevoegd. De combinatie van volgnummers van de betrokken ge\"identificeerde constraints wordt ook toegevoegd aan de propagation history. Wanneer de body van de betrokken regel niet leeg was, komen bij het toevoegen nieuwe constraints op de activatiestapel te staan, en zullen deze eerst afgewerkt worden vooraleer de verwerking van de origineel betrokken constraint voortgaat. Wanneer deze verwerking van door de body toegevoegde constraints afgelopen is, wordt overgegaan naar zoeken van partner constraints voor de volgende occurrence ({\bf Default}). Wanneer alle occurrences geprobeerd zijn, wordt de constraint van de activatiestapel verwijderd ({\bf Drop}).
\end{itemize}
Het algoritme eindigt wanneer ofwel de built-in constraint store $B$ in een inconsistentie toestand terechtkomt, of wanneer de activatiestapel leeg is. Dit uitvoeringsmechanisme werd gekozen als verfijning voor $\omega_t$ omdat het zo goed overeenkomt met de stack-gebaseerde uitvoering van de programmeertalen waarnaar CHR vertaald wordt. De activatie-stack wordt bij zulke talen dan de call stack van aangeroepen routines, waarbij deze routines zoeken naar partner constraint gegeven een actieve constraint. Zodra een nieuwe constraint toegevoegd wordt, wordt deze geactiveerd en dus alle regels die erop van toepassing zijn toegepast, vooraleer verder gegaan wordt met de oorspronkelijk actieve constraint.

Deze semantiek is nog steeds indeterministisch. Zo wordt er niet vastgelegd in welke volgorde constraint terug aan de activatiestapel toegevoegd worden, of in welke volgorde partner constraints gezocht worden indien er meerdere mogelijkheden zijn voor \'e\'en bepaalde occurrence. Deze zaken worden echter aan de implementatie overgelaten. Door de volgorde waarin over de constraint store ge\"itereerd wordt niet vast te leggen, zijn implementaties vrij een eigen geoptimaliseerde routines te gebruiken om partner constraints te vinden.

\section{Uitbreidingen}

{\bf Niet pure constraints} In principe kunnen als built-in constraints enkel pure constraints gebruikt worden. Dit wil zeggen constraints die de onderliggende constraint solver kent, en eens eraan toegevoegd geldig blijft. Prolog's unificatie en controle of gelijkheid zijn zulke constraints. In het kader van CHR als algemene programmeertaal, is het echter nuttig om meer acties als body toe te laten. De hiermee bekomen CHR programmas kunnen niet meer echt als constraint solvers beschouwd worden, maar eerder als algemene regel-gebaseerde systemen die CHR constraints gebruiken als gegevens die herschreven worden.

{\bf Head Normal Form} Tot hiertoe was gesteld dat de argumenten van constraint occurrences in de head van een CHR rule als argumenten variabelen moesten zijn. Het is echter ook mogelijk hier expressies toe te laten. Zolang deze enkel in functie staan van variabelen die elders in de head apart als argument voor een constraint voorkomen, kunnen deze beschouwd worden alsof in de plaats van de expressie een nieuwe aparte variabele stond, en een extra guard aanwezig was die gelijkheid eist tussen de variabele en de expressie. Dit is mogelijk op voorwaarde dat gelijkheid een built-in constraint is van de host-taal.

