\documentclass{beamer}

\mode<article>
{
  \usepackage{fullpage}
  \usepackage{hyperref}
}

\mode<presentation>
{
  \usepackage{hyperref}
  \setbeamertemplate{background canvas}[vertical shading][bottom=white!10,top=blue!10]
  \usetheme{Warsaw}
  \usefonttheme[onlysmall]{structurebold}
}

\usepackage{amsmath}
\usepackage{pst-tree}
\usepackage{pst-node}
\usepackage{pst-eps}
\usepackage{pstcol}
\usepackage{pstricks}
\usepackage{listings}
\usepackage{color}
\usepackage[dutch]{babel}
\usepackage{fancyvrb}
\usepackage{ulem}

\renewcommand{\emph}[1]{\textit{{#1}}}
\newcommand{\bs}{$\backslash$}

\setbeamercolor{background canvas}{bg=white}
\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}

\title{CCHR: De snelste CHR implementatie}
\subtitle{Promotor: \\
Prof. Dr. Bart Demoen \\
Begeleider: \\
Dr. ir. Tom Schrijvers}

\author{Pieter Wuille}
\date{29 maart 2007}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Overzicht}
  {\scriptsize \tableofcontents}
\end{frame}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Overzicht}
    {\scriptsize \tableofcontents[current,currentsubsection]}
  \end{frame}
}

\section{Algemeen}
\subsection{Waarom CCHR}
\frame{\frametitle{Waarom CHR in C?}
  \begin{block}{Waarom CHR in C?}
  \begin{itemize}
  \item CHR kunnen gebruiken in pure C programma's
  \item Een poging tot CHR heel snel maken: \begin{itemize}
    \item Vrijheid datastructuren
    \item Optimalisaties C compiler benutten
    \end{itemize}
  \end{itemize}
  \end{block}
}

\subsection{Structuur}
\frame{\frametitle{Opbouw CCHR}
  De verschillende stappen bij het gebruik van CCHR zijn: \\
  \vspace{2ex}
  \begin{columns}
  \column{0.45\textwidth}
  \begin{psmatrix}[rowsep=0.3,colsep=0.2]
    \psshadowbox{CCHR code} \\
                            & CCHR Compiler \\
    \psshadowbox{C macro's} & \\
                            & C Preprocessor \\
    \psshadowbox{C code}    & \\
                             & C Compiler \\
    \psshadowbox{Executable} &
    \ncline[linecolor=red]{->}{1,1}{3,1}
    \ncline{->}{3,1}{5,1}
    \ncline{->}{5,1}{7,1}
  \end{psmatrix}
  \column{0.55\textwidth}
  \begin{block}{CCHR code}
    \begin{itemize}
      \item Gewone C broncode
      \item Met ``cchr \{ \ldots \}'' blokken in
      \item Deze blokken worden vervangen door C macro's
    \end{itemize}
  \end{block}
  \end{columns}
}

\section{Implementatie}
\subsection{Mogelijkheden}
\frame[containsverbatim]{\frametitle{Mogelijkheden}
  \begin{block}{CHR Constraints}
  CHR Constraints zijn ge\"implementeerd:
  \begin{itemize}
    \item Willekeurige ariteit
    \item Alle C datatypes (behalve arrays) als argumenten
  \end{itemize}
  \end{block}
  
  \begin{example}
  \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{red}{constraint} init(int),fib(int,bignum_t)
  \textcolor{red}{destr}(destruct_bignum(&$2))\textcolor{blue}{;}
  \end{Verbatim}
  \end{example}
} %$

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  \begin{block}{CHR Rules}
  CHR Rules zijn ge\"implementeerd:
  \begin{itemize}
    \item Propagation ($ K,\ldots \textcolor{blue}{==>} \ldots $)
    \item Simplification ($ R,\ldots \textcolor{blue}{<=>} \ldots $)
    \item Simpagation ($ K,\ldots \textcolor{blue}{\backslash}\ R,\ldots \textcolor{blue}{<=>} \ldots $)
  \end{itemize}
  \end{block}
  
  \begin{example}
  \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{blue}{begin @} init(_) \textcolor{blue}{==>} fib(0,1), fib(1,1)\textcolor{blue}{;}
\textcolor{blue}{triv @} gcd(0) \textcolor{blue}{<=>} \textcolor{red}{true}\textcolor{blue}{;}
\textcolor{blue}{dec @} gcd(N) \textcolor{blue}{\bs} gcd(M) \textcolor{blue}{<=>} M>=N \textcolor{blue}{|} gcd(M-N)\textcolor{blue}{;}
  \end{Verbatim}
  \end{example}
}

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  \begin{block}{Guards en Bodys}
  De volgende zaken zijn mogelijk als guard en body:
  \begin{itemize}
   \item Voorwaardelijke expressies (enkel guard)
   \item Variabele declaraties (en initialisaties)
   \item Willekeurige C code (tussen accolades)
   \item Toe te voegen CHR contraints (enkel body)
  \end{itemize}
  \end{block}
}

\newcommand{\implstruct}[6]{
  \begin{psmatrix}[rowsep=#1,colsep=#2]
     \psovalbox{Source} & \\
     & \psovalbox{CCHR} \\
     \psframebox[linecolor=#3]{main} & \psframebox[linecolor=#4]{lexer \& parser} \\
     & \psframebox[linecolor=#5]{analyse} \\
     & \psframebox[linecolor=#6]{code generatie} \\
     \psovalbox{C code}
     \ncline[linecolor=#3]{->}{1,1}{3,1}
     \ncline[linecolor=#3]{->}{3,1}{2,2}
     \ncline[linecolor=#4]{->}{2,2}{3,2}
     \ncline[linecolor=#4]{->}{3,2}{4,2}
     \ncline[linecolor=#5]{->}{4,2}{5,2}
     \ncline[linecolor=#6]{->}{5,2}{3,1}
     \ncline[linecolor=#3]{->}{3,1}{6,1}
  \end{psmatrix}
}

\subsection{Structuur}
\frame{\frametitle{Structuur}
  \begin{columns}[c]
  \column{0.6\textwidth}
  \implstruct{3ex}{3em}{black}{black}{black}{black}
  \end{columns}
}

\frame{\frametitle{Structuur - Main, Lexer, Parser}
  \begin{columns}
   \column{.43\textwidth}
    {\small \implstruct{1.5ex}{1.5em}{red}{red}{black}{black}}
   \column{.57\textwidth}
  \begin{block}{de main module}
  \begin{itemize}
    \item Bevat de main() C routine
    \item Overloopt alle opgegeven sourcefiles
    \item Roept andere modules aan voor cchr-blokken
  \end{itemize}
  \end{block}
  \begin{block}{Lexer en Parser}
  \begin{itemize}
    \item Geschreven in Flex en Bison resp.
    \item Herkennen CCHR tokens en grammatica
    \item Enkel voor CCHR blokken
  \end{itemize}
  \end{block}
  \end{columns}
}
\frame{\frametitle{Structuur - Analyse}
  \begin{columns}
   \column{.43\textwidth}
    {\small \implstruct{1.5ex}{1.5em}{black}{black}{red}{black}}
   \column{.57\textwidth}
  \begin{block}{de analyser}
  \begin{itemize}
    \item Analyseert output van de parser (abstract syntax tree)
    \item Genereert nieuwe data structuur met expressions, variabelen, constraints, regels, \ldots
    \item Doet conversie naar Head Normal Form
    \item Optimaliseert (iteratie volgorde, propagation history, indexen, \ldots)
  \end{itemize}
  \end{block}
  \end{columns}
}
\frame{\frametitle{Structuur - Code generatie}
  \begin{columns}
   \column{.43\textwidth}
    {\small \implstruct{1.5ex}{1.5em}{black}{black}{black}{red}}
   \column{.57\textwidth}
  \begin{block}{de code-generator}
  \begin{itemize}
    \item Gebruikt de gegevens gegenereerd door analyser
    \item Genereert een aantal macro's voor elke constraint/regel
    \item Voor elke constraint occurrence een macro met code
  \end{itemize}
  \end{block}
  \end{columns}
}
\subsection{Logische variabelen}
\frame{\frametitle{Logische variabelen}
  \begin{block}{Wat?}
  \begin{itemize}
    \item Variabelen die niet noodzakelijk een waarde hebben
    \item Eventueel 'equalities' tussen bekend
    \item vgl. met Prolog
  \end{itemize}
  \end{block}
  \begin{block}{Implementatie}
  \begin{itemize}
    \item Gebruikt 'Union-Find' algoritme voor efficientie
    \item Aan te roepen met een C macro
    \item Voorlopig los van CCHR zelf
  \end{itemize}
  \end{block}
}
\subsection{Hashtables}
\frame{\frametitle{Hashtables}
  \begin{block}{Waarom?}
  Versnellen van opzoekingen:
  \begin{itemize}
    \item Propagation-history checks
    \item Iteratie over constraints met bepaald argument
    \item Iteratie over logische variabelen en reactivatie ervan
  \end{itemize}
  \end{block}
  \begin{block}{Implementatie}
  \begin{itemize}
    \item Alweer gedefinieerd door C macros
    \item Als hash-algoritme: lookup3
    \item Als table-algoritme: cuckoo-hashing
  \end{itemize}
  \end{block}
}
\frame{\frametitle{Hashtables - Lookup3}
  \begin{block}{Lookup3}
  \begin{itemize}
    \item Willekeurige bytesequenties als key
    \item Heel uniform, gecontroleerd voor veel patronen
    \item Waarschijnlijk overkill voor heel simpele keys
  \end{itemize}
  \end{block}
}
\frame{\frametitle{Hashtables - Cuckoo Hashing}
  \begin{block}{Cuckoo Hashing}
  \begin{itemize}
    \item 2 aparte hashtables, met onafhankelijke hashfunctie
    \item Indien een plaats bezet in table 1, overschrijven en oud element in table 2 plaatsen. Indien dat bezet \ldots
    \item Vrij simpel te implementeren
    \item Geen aparte list per plaats nodig, en geen fragmentatie
    \item Enkel lastig om over te itereren
  \end{itemize}
  \end{block}
}
\frame[containsverbatim]{\frametitle{Hashtables - Gebruik}
  \begin{block}{Wanneer?}
  \begin{itemize}
    \item Propagation history wordt erin bijgehouden
    \item Gelijkheden in guards worden hashtable indexen
  \end{itemize}
  \end{block}
  \begin{example}
  \begin{Verbatim}[commandchars=\\\{\}]
\textcolor{blue}{dec @} fib(N2,F1) \textcolor{blue}{\bs} fib(N1,F2) \textcolor{blue}{<=>}
  alt(N1+1==N2,N1==N2-1) \textcolor{blue}{|} fib(N2+1,F1+F2)\textcolor{blue}{;}
  \end{Verbatim}
  \end{example}
}
    
\section{Resultaten}

\subsection{Performantie}
\frame{\frametitle{Resultaten}
  \begin{block}{resultaten}
  \begin{tabular}{c|ccc|l}
  test & swi-prolog & jchr & cchr & test\\
  \hline
  gcd & 37.1s & - & 0.084 & gcd(100000000,5) \\
  fib & 708s & 5.0s & 0.023s & fib up to 7499 \\
  primes & 4.12s & 4.3s & 0.090s & primes up to 7500 \\
  tak & 6.19s & 0.57s & 0.048s & tak(500,450,405) \\
  ram & 0.63s & 0.62s & 0.016s & count to 2750 \\
  \hline
  avg & 291 & 46.7 & 1 & relative averages\\
  \end{tabular}
  \end{block}
}

\subsection{Voorbeelden}
\frame[containsverbatim]{\frametitle{Voorbeeld - CCHR code}
  \begin{example}
  \begin{Verbatim}[commandchars=\\\{\}]
constraint fib(int,uint64_t);
  
begin @ init(_) ==> fib(0,1ULL), fib(1,1ULL);
calc @  init(Max), fib(N2,M2) \bs fib(N1,M1) <=> 
  alt(N2==N1+1,N2-1==N1), N2<Max | fib(N2+1, M1+M2);
  \end{Verbatim}
  \end{example}
}
\frame[containsverbatim]{\frametitle{Voorbeeld - C Macros}
  \begin{example}[generated code]
  {\scriptsize \begin{Verbatim}[commandchars=\\\{\}]
#define CODELIST_fib_2_calc_R1 \bs 
  CSM_IMMLOCAL(int,N1,CSM_ARG(fib_2,arg1)) \bs
  CSM_IMMLOCAL(uint64_t,M1,CSM_ARG(fib_2,arg2)) \bs
  CSM_DEFIDXVAR(fib_2,idx1,K2) \bs
  CSM_SETIDXVAR(fib_2,idx1,K2,arg1,CSM_LOCAL(N1) + 1) \bs
  CSM_IDXLOOP(fib_2,idx1,K2, \bs
    CSM_IF(CSM_DIFFSELF(K2), \bs
      CSM_IMMLOCAL(int,N2,CSM_LARG(fib_2,K2,arg1)) \bs
      CSM_IMMLOCAL(uint64_t,M2,CSM_LARG(fib_2,K2,arg2)) \bs
      CSM_LOOP(init_1,K1, \bs
        CSM_IMMLOCAL(int,Max,CSM_LARG(init_1,K1,arg1)) \bs
        CSM_IF(CSM_LOCAL(N2) < CSM_LOCAL(Max), \bs
          CSM_KILLSELF(fib_2) \bs
          CSM_ADD(fib_2,CSM_LOCAL(N2)+1,CSM_LOCAL(M1)+CSM_LOCAL(M2)) \bs
          CSM_END \bs
        ) \bs
      ) \bs
    ) \bs
  )
\end{Verbatim}
  }\end{example}
}
\end{document}
