\chapter{CHR in Java} \label{chap:chr-java}

In dit hoofdstuk wordt ingegaan op de bestaande implementaties van CHR in de programmeertaal Java. 

\section{JaCK --- The Java Constraint Kit}

JaCK is een project met als doel Constraint Solving mogelijkheden aan Java toevoegen. Het bestaat uit drie delen, JCHR, VisualCHR en JASE. JCHR maakt het mogelijk om CHR regels in een Java-achtige syntax te gebruiken in Java. JASE, ofwel Java Abstract Search Engine, breidt de mogelijkheden uit met zoekstrategie\"en. Hierdoor is het mogelijk om JaCK te gebruiken voor probleem waar Constraint Propagation geen volledige oplossing geeft. Het maakt zogenaamde parti\"ele solvers mogelijk. JaCK wordt beschreven in \cite{jack}.
\begin{exCode}[bhp]
\begin{Verbatim}[frame=single]
handler leq {
  class java.lang.Integer;
  
  constraint leq(java.lang.Integer, java.lang.Integer);
  
  rules {
    variable java.lang.Integer X, Y, Z;
    
    if (X = Y) { leq(X,Y) } <=> { true } reflexivity;
    { leq(X, Y) && leq(Y, X) } <=> { X = Y } antisymmetry;
    { leq(X, Y) &\& leq(X, Y) } <=> { true } idempotence;
    { leq(X, Y) && leq(Y, Z) } ==> { leq(X, Z) } transitivty;
  }
}
\end{Verbatim}
\caption{Kleiner-dan-of-gelijk-aan in JaCK}
\label{code:leq-jack}
\end{exCode}
Het opvallendste aan de syntax zoals die te zien is in codevoorbeeld~\ref{code:leq-jack}, is het afwijken van de standaard syntax voor CHR rules.

\section{CHORD}

CHORD\cite{chord} is een implementatie van CHR in Java, waarbij de CHR$^\vee$ uitbreiding ondersteund is. CHR$^\vee$ laat disjuncties toe binnen de body van CHR rules. Hierdoor ontstaan verschillende keuzemogelijkheden voor de uitvoering, waarbij toch backtracking noodzakelijk kan worden, indien de eerste mogelijkheid niet tot een oplossing leidt. Aldus combineert het de mogelijkheden van CHR met SLD-resolutie. In tegenstelling tot CHR is CHR$^\vee$ niet volledig {\em committed-choice}. CHR$^\vee$ wordt uitgebreider besproken in \cite{chrv}.

\begin{exCode}[bhp]
\begin{Verbatim}[frame=single]
// Definition rules
parent(C,P) <=> true | (father(P,C) ; mother(P,C)).
sibling(C1,C2) <=> true | ne(C1,C2), parent(P,C1), parent(P,C2).

// integrity constraints
father(F1,C), father(F2,C) ==> true | F1 = F2.
mother(M1,C), mother(M2,C) ==> true | M1 = M2.
person(G1,C), person(G2,C) ==> true | G1 = G2.
father(F,C) ==> true | person(F,"male"), person(C,S).
mother(M,C) ==> true | person(M,"female"), person(C,G).
\end{Verbatim}
\caption{Familie-relaties in CHORD}
\label{code:familie-chord}
\end{exCode}
Codevoorbeeld~\ref{code:familie-chord} toont hoe een eenvoudig familie-relatie programma ge\"implementeerd kan worden in CHORD. De allereerste regel maakt gebruikt van het disjunctie-symbool \code{;} om aan te geven dat een ouder ofwel een vader ofwel een moeder is.
