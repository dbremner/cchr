\chapter{CHR in Prolog}

In dit hoofdstuk wordt een kort overzicht gegeven van de bestaande CHR implementaties in Prolog.

\section{Geschiedenis}

De eerste volledige CHR implementatie, zoals beschreven in \cite{christian:system}, werd gemaakt voor SICStus Prolog (meer informatie in \cite{sicstus}). Deze werd geschreven door Christian Holzbaur en Thom Fr\"uhwirth, en wordt algemeen als de referentie-implementatie beschouwd. Een compatibel systeem werd later geschreven voor Yap (zie \cite{yap}). Een oudere, onvolledige versie werd ook geschreven voor ECL$^i$PS$^e$ \cite{eclipse}.

\section{Het K.U.Leuven CHR systeem}

Een nieuwere implementatie was het K.U.Leuven CHR systeem \cite{tom:kulchr}. Het werd oorspronkelijk voor hProlog gemaakt, maar bestaat ondertussen ook voor XSB Prolog \cite{xsb} en SWI-Prolog \cite{swiprolog}, zoals beschreven in \cite{tom:swi:wclp2005}). De nieuwe release van SICStus Prolog (4.0), maakt ook gebruik van K.U.Leuven CHR.

Dit systeem maakt gebruik van een vertaling van CHR regels naar Prolog zelf, die dan binnen de respectievelijke Prolog runtime uitgevoerd kan worden. Deze vertaling gebeurt bij het inladen van de Prolog broncode zelf, wat een vertraging teweegbrengt bij het opstarten van een CHR programma in Prolog.

Constraints nemen de vorm aan van predikaten, met een naam en een ariteit. Ze moeten gedeclareerd worden als constraint, in plaats van normaal predikaat. Dat gebeurt dat met: \begin{Verbatim}
  :- chr_constraint upto(+int),prime(+int).
\end{Verbatim}
Hiermee wordt duidelijk gemaakt dat \code{upto/1} en \code{prime/1} geen predikaten maar constraints zijn. In dit specifiek voorbeeld wordt daarbij gesteld dat het argument ervan een \code{int} moet zijn, en dat dit altijd {\em ground} is, wat wilt zeggen, altijd reeds een waarde heeft op het moment dat de constraint aangeroepen wordt.

Voor het specificeren van de CHR rules wordt volledig de syntax gevolgd die in sectie~\ref{sec:chr-syntax} gegeven werd. In de heads mogen alle vooraf gedeclareerde CHR constraints gebruikt worden, en als argumenten variabelen. Zoals gebruikelijk in Prolog zijn deze vereist te beginnen met een hoofdletter. Het is ook mogelijk een anonieme variabele te gebruiken, door de naam ervan met een underscore (\code{\_}) te laten beginnen. Een anonieme variabele wordt verondersteld slechts \'e\'enmalig per regel voor te komen, terwijl een normale variabele slechts \'e\'enmalig vermelden een waarschuwing zal geven. Dit duidt meestal op een fout van de programmeur.

Als body wordt alles toegestaan wat in een Prolog goal kan. Dat houdt ook CHR constraints in, die ook gelden als gebruiker-gedefinieerde predikaten. In de guard worden dezelfde dingen toegelaten, behalve CHR constraints. Dat houdt ook 

