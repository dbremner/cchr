\documentclass{beamer}
\usepackage{beamerthemesidebar}
\usepackage{amsmath}

\title{CCHR}
\subtitle{De snelste CHR implementatie}

\author{Pieter Wuille}
\date{\today}

\begin{document}

\frame{\titlepage}

\section[Overzicht]{}
\begin{frame}
  \frametitle{Overzicht}
  {\scriptsize \tableofcontents}
\end{frame}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Overzicht}
    {\scriptsize \tableofcontents[current,currentsubsection]}
  \end{frame}
}

\section{Algemeen}
\subsection{Waarom CCHR}
\frame{\frametitle{Waarom CHR in C?}
  \begin{itemize}
  \item De mogelijkheid om CHR te gebruiken in pure C programma's
  \item CHR compiler veel vrijheid geven inzake datastructuren
  \end{itemize}
}

\subsection{Structuur}
\frame{\frametitle{Opbouw CCHR}
  De verschillende stappen bij het gebruik van CCHR zijn:
  \begin{enumerate}
    \item Schrijven van C code met "cchr \{ \ldots \}" blokken in
    \item CCHR compiler zet blokken om in een hoop macro's
    \item C preprocessor zet macro's om in C code
    \item C compiler compileert verder (assembler, object, executable)
  \end{enumerate}
}

\section{Implementatie}
\subsection{Mogelijkheden}
\frame{\frametitle{Mogelijkheden}
  Momenteel geimplementeerd:
  \begin{itemize}
    \item CHR Constraints (willekeurige ariteit, en bijna alle C-datatypes)
    \item CHR Rules (propagation, simplification, simpagation)
    \item Variabelen in rules (in head, guard of body gedefinieerd)
    \item Rules in niet-HNF vorm
    \item Willekeurige C-expressies als guards of constraint-argumenten
    \item C code (statements) in guard of body
    \item Debug modus
    \item User-definied destructors
  \end{itemize}
}
\subsection{Overzicht}
\frame{\frametitle{Overzicht}
  De huidige versie van de CCHR Compiler werkt in deze stappen:
  \begin{enumerate}
    \item Algemene routine die "cchr \{ \ldots \}" blokken detecteert
    \item Een lexer, gegenereerd mbv. Flex
    \item Een parser, gegenereerd mbv. Bison
    \item Semantische acties in Bison die eerste data structuur opbouwen
    \item Een analyse-fase die code en constraint- en variabelenamen herkent 
          en bv. HNF omzetting doet
    \item Een code-generatie fase die een lijst C macro definities genereert
    \item Een outputroutine die wat indentatie doet
  \end{enumerate}
}
\frame{\frametitle{De "main" module}
  \begin{itemize}
    \item Bevat de main() C routine
    \item Overloopt alle opgegeven sourcefiles
    \item Vervangt .chr of .cchr door .c voor output
    \item Kopieert input naar output, behalve cchr-blokken
    \item Voor cchr blokken worden lexer, parser, analyser en code-generator aangeroepen
  \end{itemize}
}
\frame{\frametitle{De lexer \& parser}
  De lexer:
  \begin{itemize}
    \item Geschreven mbv. Flex (die lexer genereert in C)
    \item Herkent operatoren, haakjes, symbolen
    \item Parser vraagt deze "tokens" op aan lexer
  \end{itemize}

  De parser:
  \begin{itemize}
    \item Geschreven mbv. Bison (die parser genereert in C)
    \item Herkent regels, code-blokken, argumenten, constraints, \ldots
  \end{itemize}
}
\frame{\frametitle{De analyse}
  De analyzer:
  \begin{itemize}
    \item Analyseert output van de parser (abstract syntax tree)
    \item Genereert nieuwe data structuur met expressions, variabelen, constraints, regels, \ldots
    \item Doet conversie naar Head Normal Form
    \item Analyseert gebruik van variabelen, waar propagation history bij te houden, \ldots
  \end{itemize}
}
\frame{\frametitle{De code-generatie}
  De code-generatie:
  \begin{itemize}
    \item Gebruikt de gegevens genereerd door analyser
    \item Genereert een aantal macro's voor elke constraint/regel
    \item Voor elke constraint occurrence een macro met code
  \end{itemize}
}
\section{Moeilijkheden en ontwerpbeslissingen}
\subsection{Geheugenallocatie}
\frame{\frametitle{Geheugenallocatie}
  \begin{itemize}
    \item Alle ge-malloc()-ed geheugen wordt ge-free()-d
    \item Garbage Collector is niet noodzakelijk, dmv. user-defined destructors
    \item Eventueel kan alternatieve malloc()/free() gebruikt worden (eg. Boehm)
  \end{itemize}
}
\subsection{Macro's}
\frame{\frametitle{Gebruik van C macro's}
  Voordelen van gebruik van macro's:
  \begin{itemize}
    \item Minder echte code in CCHR compiler zelf (hardcoded)
    \item Keuze van eg. datastructuren kan buiten compiler
    \item Overzichtelijkere outputcode
    \item Debug-mode door simpel optie meegeven aan C compiler
  \end{itemize}
  Nadelen:
  \begin{itemize}
    \item Veel moeilijker locatie van bugs te vinden
    \item Macro definities redelijk moeilijk leesbare code
  \end{itemize}
}
\section{Performantie}
\frame{\frametitle{Algemeen}
  \begin{itemize}
    \item HW: AMD Athlon64 3500+, 1Gb PC3200 DDR RAM
    \item C Compiler: GCC 4.1.1, -O3 -march=athlon64
    \item Java: Sun JRE 1.5 64-bit Hotspot; JCHR 1.5
    \item Prolog: v5.6.24 for amd64
  \end{itemize}
}
\subsection{GCD Example}

\section{LR Parsing}
\subsection{Techniek}
\frame{\frametitle{De zwakte van LL}
  LL(k) parsers zijn niet krachtig genoeg
  \begin{itemize}
  \item LL(k) parsers voorspellen welke productie te gebruiken
  \item Ze kennen enkel de k eerste tokens van de afleiding
  \item We willen die beslissing achteraf pas nemen
  \end{itemize}
  $\rightarrow$ LR(k) Parsing
  \begin{itemize}
  \item ``Left-to-right parse, {\bf Rightmost-derivation}, k-token lookahead''
  \item Left-to-right parse: we parseren van links naar rechts
  \item Rightmost-derivation: rechte afleiding: steeds het meest rechtse NTS vervangen
  \item k-symbol lookahead: k tekens vooruit kijken (zelden $>1$)
  \end{itemize}
}
\frame{\frametitle{LR(k) techniek}
  \begin{itemize}
  \item Hoe kunnen we een rechtse afleiding doen als parser links begint?
  \item Door een stack van symbolen (TS en NTS) bij te houden
  \item Op basis van de inhoud van de stack en komende symbolen: \begin{itemize}
    \item Ofwel een token uit input op stack zetten
    \item Ofwel aantal symbolen bovenop stack tot 1 NTS reduceren
    \end{itemize}
  \end{itemize}
}
\frame{\frametitle{Gebruik van DFA}
  Hoe implementeren we zo'n LR(k) parser?
  \begin{itemize}
  \item Zoals aangetoond zijn DFA's niet voldoende krachtig
  \item We kunnen DFA wel gebruiken op stack ipv input
  \item Elke ``positie'' in een productieregel is een toestand
  \item Overgangen tussen toestanden zijn symbolen (TS of NTS)
  \end{itemize}
}
\frame{\frametitle{Werking van DFA in LR parser}
  We kunnen bij elke toevoeging van een element onthouden in welke
  toestand de DFA daarmee komt, zodat niet telkens de hele stack doorlopen
  moet worden. Zie figuur 3.17 in boek. \\
  De acties in deze tabel: \begin{description}
  \item[Shift(n)] Zet volgend token met state n op stack
  \item[Reduce(k)] {\scriptsize \begin{itemize}
    \item Haal (\# symbolen in rechterkant regel k) van stack
    \item Noem X de NTS aan linkerkant van regel k
    \item Zoek in state nu bovenop stack de actie voor X
    \item Volg de ``goto b'' daar, zet X (met state n) bovenop stack
    \end{itemize}}
  \item[Accept] Shiften van \$: klaar
  \item[Error] (lege plaats) ongeldige input
  \end{description}
}
\subsection{LR(0) parsers}
\frame{\frametitle{Opstellen states en overgangstabel}
  Eerst moeten we alle states opstellen: \begin{itemize}
  \item We beginnen met de S'$\rightarrow$.S\$ state
  \item de ``.'' duidt het einde van de stack aan
  \item Volg nu volgende regels: \begin{itemize}
    \item ``.'' staat voor NTS X: voeg alle X$\rightarrow$.$\alpha$ regels toe aan state (closure)
    \item ``.'' staat voor symbool $\gamma$: maak state n met zelfde regel maar ``.'' na $\gamma$ (goto) \begin{description}
      \item[NTS] zet goto(n) in overgangstabel
      \item[TS] zet shift(n) in overgangstabel
      \end{description}
    \item ``.'' staat op einde regel k: zet reduce(k) in overgangstabel
    \item shift van \$ is een accept
    \end{itemize}
  \item Ga door tot er geen nieuwe states meer zijn.
  \end{itemize}
}
\subsection{SLR parsers}
\frame{\frametitle{Shift-Reduce conflicten}
  Stel we proberen een LR(0) parser voor deze grammatica:
  \begin{tabular}{ll}
    S$\rightarrow$E\$ & E$\rightarrow$T \\
    E$\rightarrow$T+E & T$\rightarrow$x \\
  \end{tabular}
  \quad \\
  $\rightarrow$ toestand ``E$\rightarrow$T.+E'' en ``E$\rightarrow$T.'' als regels.
  $\rightarrow$ Als er ``+'' volgt, moet zowel een shift als een reduce gebeuren. \\
  Dit heet een {\bf shift-reduce conflict}. \\
  $\rightarrow$ Deze grammatica is niet LR(0). \\
  $\rightarrow$ We hebben iets krachtiger nodig
}
\frame{\frametitle{SLR Parser generatie}
  \begin{tabular}{ll}
    S$\rightarrow$E\$ & E$\rightarrow$T \\
    E$\rightarrow$T+E & T$\rightarrow$x \\
  \end{tabular}
  \quad \\
  \begin{itemize}
  \item LR(0) zet reduce op elk token in tabel
  \item Beter: enkel bij tokens uit FOLLOW(A) (bij A$\rightarrow \alpha$ regel) $\rightarrow$ minder Shift-Reduce conflicten (wegens minder Reduce's)
  \item Dit heet SLR (Simple LR)
  \item Bovenstaande grammatica is SLR
  \item SLR is krachtiger dan LR(0)
  \end{itemize}
}
\subsection{LR(1) parsers}
\frame{\frametitle{Nog krachtiger dan SLR}
  SLR vermijdt een deel overbodige reduce's, maar echt reduce's laten afhangen van volgend token kan niet.
  $\rightarrow$ LR(1) parsers \begin{itemize}
  \item In toestandstabellen wordt extra volgend token opgenomen (niet na \$)
  \item Toestanden zijn verschillend als volgend token verschilt
  \item Reduce acties worden enkel geplaatst bij die volgende tokens.
  \end{itemize}
  $\rightarrow$ zeer veel toestanden
}
\frame{\frametitle{LALR(1) parsers}
  Omdat LR(1) tables heel groot kunnen worden, voert men een vereenvoudiging door: \begin{itemize}
  \item Toestanden die op volgend token na identiek zijn worden samengenomen
  \item De bekomen parser heet LALR(1) (Look-Ahead LR(1))
  \item LALR(1) is krachtiger dan SLR (een SLR taal is ook LALR(1))
  \item LALR(1) is wel zwakker dan LR(1)
  \item Bijna alle praktische talen zijn LALR(1)
  \end{itemize}
  $\rightarrow$ er zijn veel LALR(1) parser generators beschikbaar (yacc, bison)
}
\frame{\frametitle{Ambiguiteit en Shift-Reduce conflicten}
  \begin{itemize}
  \item Stel een grammatica als: ``S$\rightarrow$if E then S else S'', ``S$\rightarrow$if E then S''.
  \item Dit laat zinnen als ``if a then if b then s1 else s2'' toe
  \item Er zijn 2 interpretaties: \begin{itemize}
    \item if a then \{ if b then s1 else s2 \}
    \item if a then \{ if b then s1 \} else s2
    \end{itemize}
  \item Dit wordt een shift-reduce conflict in een LR parse table
  \item We kunnen kiezen om toch te shiften, door voor het eerste te kiezen
  \item Dit is gevaarlijk, maar laat toe ambigue talen te parsen
  \end{itemize}
}
\section{Parser generators}
\subsection{YACC}
\frame{\frametitle{YACC}
  Het genereren van LR(1) (en vooral LALR(1)) parse tables kan geautomatiseerd worden.
  
  De traditionale applicatie hiervoor is YACC (Yet Another Compiler-Compiler), \\
  maar er zijn modernere implementaties zoals Bison. \\
  Werking: \begin{itemize}
  \item Neemt als input een ``grammar file''
  \item LALR(1) parse table wordt opgesteld
  \item Parse table + LALR(1) parse algoritme $\rightarrow$ C code 
  \item Code bevat functie yyparse() \begin{itemize}
    \item roept functie yylex() aan om de tokens te verkrijgen
    \item roept functie yyerror() aan bij een fout
    \item voert acties uit grammar file uit bij elke reductie
    \end{itemize}
  \end{itemize}
}
\frame{\frametitle{YACC grammar}
  De syntax van YACC grammar files:
  \begin{itemize}
  \item Eerst een specifieke header voor declaratie yylex() en yyparse()
  \item Vernoeming alle lexer tokens (TS)
  \item Vernoemen startsymbool
  \item Eventueel wat opties zoals voorrangsregels
  \item Dan een lijst met alle productieregels
  \end{itemize}
  (zie voorbeeld)
}
\subsection{Conflicten}
\frame{\frametitle{YACC en conflicten}
  \begin{itemize}
  \item YACC detecteert shift-reduce en reduce-reduce conflicten
  \item Standaard is dit geen error, maar wordt dit gedaan: \begin{itemize}
    \item Bij Shift-Reduce conflicten wordt shift gekozen
    \item Bij Reduce-Reduce conflicten wordt eerst vermeldde regel gekozen
    \end{itemize}
  \item Er kunnen prioriteitsregels gegeven worden om dit gedrag te veranderen
  \end{itemize}
  (zie voorbeeld)
}
\subsection{Voor volgende week}
\frame{\frametitle{Semantiek is voor volgende week}
  Men kan geneigd zijn een parser teveel te laten doen:
  \begin{itemize}
  \item De parser moet enkel de structuur van de zinnen achterhalen
  \item Niet alle operatoren mogen misschien op alle argumenten
  \item Zaken als data-types horen niet thuis in de grammatica
  \end{itemize}
  $\rightarrow$ Deze dingen worden in de semantische analyse gedaan
}
\frame{\frametitle{THE END}
  \begin{center} {\huge EINDE} \end{center}
}
\end{document}
