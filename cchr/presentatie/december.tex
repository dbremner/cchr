\documentclass{beamer}
\usepackage{beamerthemesidebar}
\usepackage{amsmath}

\title{CCHR}
\subtitle{De snelste CHR implementatie}

\author{Pieter Wuille}
\date{\today}

\begin{document}

\frame{\titlepage}

\section[Overzicht]{}
\begin{frame}
  \frametitle{Overzicht}
  {\scriptsize \tableofcontents}
\end{frame}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Overzicht}
    {\scriptsize \tableofcontents[current,currentsubsection]}
  \end{frame}
}

\section{Algemeen}
\subsection{Waarom CCHR}
\frame{\frametitle{Waarom CHR in C?}
  \begin{itemize}
  \item De mogelijkheid om CHR te gebruiken in pure C programma's
  \item CHR compiler veel vrijheid geven inzake datastructuren
  \end{itemize}
}

\subsection{Structuur}
\frame{\frametitle{Opbouw CCHR}
  De verschillende stappen bij het gebruik van CCHR zijn:
  \begin{enumerate}
    \item Schrijven van C code met "cchr \{ \ldots \}" blokken in
    \item CCHR compiler zet blokken om in een hoop macro's
    \item C preprocessor zet macro's om in C code
    \item C compiler compileert verder (assembler, object, executable)
  \end{enumerate}
}

\section{Implementatie}
\subsection{Mogelijkheden}
\frame{\frametitle{Mogelijkheden}
  Momenteel geimplementeerd:
  \begin{itemize}
    \item CHR Constraints (willekeurige ariteit, en bijna alle C-datatypes)
    \item CHR Rules (propagation, simplification, simpagation)
    \item Variabelen in rules (in head, guard of body gedefinieerd)
    \item Propagation history (enkel rules zonder removed constraints)
    \item Rules in niet-HNF vorm
    \item Willekeurige C-expressies als guards of constraint-argumenten
    \item C code (statements) in guard of body
    \item Debug modus
    \item User-definied destructors
  \end{itemize}
}
\subsection{Overzicht}
\frame{\frametitle{Overzicht}
  De huidige versie van de CCHR Compiler werkt in deze stappen:
  \begin{enumerate}
    \item Algemene routine die "cchr \{ \ldots \}" blokken detecteert
    \item Een lexer, gegenereerd mbv. Flex
    \item Een parser, gegenereerd mbv. Bison
    \item Semantische acties in Bison die eerste data structuur opbouwen
    \item Een analyse-fase die code en constraint- en variabelenamen herkent 
          en bv. HNF omzetting doet
    \item Een code-generatie fase die een lijst C macro definities genereert
    \item Een outputroutine die wat indentatie doet
  \end{enumerate}
}
\frame{\frametitle{De "main" module}
  \begin{itemize}
    \item Bevat de main() C routine
    \item Overloopt alle opgegeven sourcefiles
    \item Vervangt .chr of .cchr door .c voor output
    \item Kopieert input naar output, behalve cchr-blokken
    \item Voor cchr blokken worden lexer, parser, analyser en code-generator aangeroepen
  \end{itemize}
}
\frame{\frametitle{De lexer \& parser}
  De lexer:
  \begin{itemize}
    \item Geschreven mbv. Flex (die lexer genereert in C)
    \item Herkent operatoren, haakjes, symbolen
    \item Parser vraagt deze "tokens" op aan lexer
  \end{itemize}

  De parser:
  \begin{itemize}
    \item Geschreven mbv. Bison (die parser genereert in C)
    \item Herkent regels, code-blokken, argumenten, constraints, \ldots
  \end{itemize}
}
\frame{\frametitle{De analyse}
  De analyzer:
  \begin{itemize}
    \item Analyseert output van de parser (abstract syntax tree)
    \item Genereert nieuwe data structuur met expressions, variabelen, constraints, regels, \ldots
    \item Doet conversie naar Head Normal Form
    \item Analyseert gebruik van variabelen, waar propagation history bij te houden, \ldots
  \end{itemize}
}
\frame{\frametitle{De code-generatie}
  De code-generatie:
  \begin{itemize}
    \item Gebruikt de gegevens gegenereerd door analyser
    \item Genereert een aantal macro's voor elke constraint/regel
    \item Voor elke constraint occurrence een macro met code
  \end{itemize}
}
\section{Moeilijkheden en ontwerpbeslissingen}
\subsection{Geheugenallocatie}
\frame{\frametitle{Geheugenallocatie}
  \begin{itemize}
    \item Alle ge-malloc()-ed geheugen wordt ge-free()-d
    \item Garbage Collector is niet noodzakelijk, dmv. user-defined destructors
    \item Eventueel kan alternatieve malloc()/free() gebruikt worden (eg. Boehm)
  \end{itemize}
}
\subsection{Macro's}
\frame{\frametitle{Gebruik van C macro's}
  Voordelen van gebruik van macro's:
  \begin{itemize}
    \item Minder echte code in CCHR compiler zelf (hardcoded)
    \item Keuze van eg. datastructuren kan buiten compiler
    \item Overzichtelijkere outputcode
    \item Debug-mode door simpel optie meegeven aan C compiler
  \end{itemize}
  Nadelen:
  \begin{itemize}
    \item Veel moeilijker locatie van bugs te vinden
    \item Macro definities redelijk moeilijk leesbare code
  \end{itemize}
}
\section{Performantie}
\frame{\frametitle{Algemeen}
  \begin{itemize}
    \item HW: AMD Athlon64 3500+, 1Gb PC3200 DDR RAM
    \item C Compiler: GCC 4.1.1, -O3 -march=athlon64
    \item Java: Sun JRE 1.5 64-bit Hotspot; JCHR 1.5
    \item Prolog: v5.6.24 for amd64
  \end{itemize}
}
\subsection{GCD Example}
\frame{\frametitle{GCD Voorbeeld}
  constraint gcd(uint64\_t); \\
  triv @ gcd(0ULL) $<=>$ true; \\
  dec @ gcd(N) $\backslash$ gcd(M) $<=>$ M$>=$N $|$ gcd(M-N); \\
  \vspace{2ex}
  Beginnen met: gcd(100000000),gcd(5). \\
  \vspace{2ex}
  \begin{tabular}{c|cc}
    implementatie & runtime & cycles/iteratie \\
    \hline
    swi-prolog & 37.1s & 4100 \\
    cchr       & 0.08s & 8.8
  \end{tabular}
}
\subsection{FIB Example}
\frame{\frametitle{FIB Voorbeeld (met GMP library)}
  typedef struct \{ mpz\_t v; \} bigint\_t; \\
  \vspace{2ex}
  constraint fib(int,bigint\_t) destr(mpz\_clear(Arg2.v)); \\
  constraint init(int); \\
  \vspace{2ex}
  begin @ init(\_) $==>$ bigint\_t Z=, bigint\_t Y=, \{ \\
  \quad mpz\_init\_set\_si(Z.v,1); \\
  \quad mpz\_init\_set\_si(Y.v,1); \\
  \}, fib(0,Z), fib(1,Y); \\
  \vspace{2ex}
  calc @ init(Max), fib(N-1,M1), fib(N,M2) $==>$ N$<$Max $|$ bigint\_t Sum=, \{ \\
  \quad mpz\_init(Sum.v); \\
  \quad mpz\_add(Sum.v,M1.v,M2.v); \\
  \}, fib(N+1, Sum); \\
  \vspace{2ex}
  fini @ init(\_) $<=>$ true; \\
}
\frame{\frametitle{Resultaten FIB}
  Beginnen met: init(7499). \\
  Versie 2 gebruikt: \\
  \quad fini @ fib(Max,\_) $\backslash$ init(Max) $<=>$ true; \\
  in plaats van: \\
  \quad fini @ init(\_) $<=>$ true; \\
  \vspace{2ex}
  \begin{tabular}{c|cc}
    implementatie & runtime(v1) & runtime(v2) \\
    \hline
    swi-prolog & 740s & 294s \\
    jchr & 4.56s & 0.149s \\
    cchr & 2.06s & 1.22s \\
    cchr (no hist) & - & 0.505s
  \end{tabular}
}

\section{Gepland werk}
\frame{\frametitle{Gepland werk}
  \begin{itemize}
    \item Meer optimalisaties (statische analyse)
    \item Built-in constraints (mbv. union find) \& reactivatie
    \item Meer datastructuren (eg. hashtables)
    \item Functies om over constraint store te itereren
  \end{itemize}
}

\section*{Einde}
\frame{\frametitle{Nog vragen?}
  Einde
}
\end{document}
