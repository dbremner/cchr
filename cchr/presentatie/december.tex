\documentclass{beamer}

\mode<article>
{
  \usepackage{fullpage}
  \usepackage{hyperref}
}

\mode<presentation>
{
  \setbeamertemplate{background canvas}[vertical shading][bottom=red!10,top=blue!10]
  \usetheme{Frankfurt}
  \usefonttheme[onlysmall]{structurebold}
}

\usepackage{amsmath}
\usepackage{pst-tree}
\usepackage{pst-node}
\usepackage{pst-eps}
\usepackage{pstcol}
\usepackage{pstricks}
\usepackage{listings}
\usepackage{color}
\usepackage[dutch]{babel}
\usepackage{fancyvrb}
\usepackage{ulem}

\renewcommand{\emph}[1]{\textit{{#1}}}

\setbeamercolor{background canvas}{bg=white}
%\setbeamertemplate{footline}[frame number]
\setbeamertemplate{navigation symbols}{}

\title{CCHR}
\subtitle{De snelste CHR implementatie}

\author{Pieter Wuille}
\date{20 december 2006}

\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Overzicht}
  {\scriptsize \tableofcontents}
\end{frame}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Overzicht}
    {\scriptsize \tableofcontents[current,currentsubsection]}
  \end{frame}
}

\section{Algemeen}
\subsection{Waarom CCHR}
\frame{\frametitle{Waarom CHR in C?}
  \begin{itemize}
  \item De mogelijkheid om CHR te gebruiken in pure C programma's
  \item CHR compiler veel vrijheid geven inzake datastructuren
  \end{itemize}
}

\subsection{Structuur}
\frame{\frametitle{Opbouw CCHR}
  De verschillende stappen bij het gebruik van CCHR zijn: \\
  \vspace{2ex}
  \begin{psmatrix}[rowsep=0.3,colsep=0.3]
    \psshadowbox{CCHR code} & \\
                            & CCHR Compiler \\
    \psshadowbox{C macro's} & \\
                            & C Preprocessor \\
    \psshadowbox{C code}    & \\
                             & C Compiler \\
    \psshadowbox{Executable} &
    \ncline[linecolor=red]{->}{1,1}{3,1}
    \ncline{->}{3,1}{5,1}
    \ncline{->}{5,1}{7,1}
  \end{psmatrix}
  %\begin{enumerate}
   % \item Schrijven van C code met "cchr \{ \ldots \}" blokken in
    %\item CCHR compiler zet blokken om in een hoop macro's
    %\item C preprocessor zet macro's om in C code
    %\item C compiler compileert verder (assembler, object, executable)
  %\end{enumerate}
}

\section{Implementatie}
\subsection{Mogelijkheden}
\frame[containsverbatim]{\frametitle{Mogelijkheden}
  CHR Constraints zijn ge\"implementeerd:
  \begin{itemize}
    \item Willekeurige ariteit
    \item Alle C datatypes (behalve arrays) als argumenten
    \item Extra parameters voor weergave of voor destructors
  \end{itemize}
  
  \begin{block}{voorbeeld}
  \begin{Verbatim}
constraint init(int),fib(int,bignum_t)
  destr(destruct_bignum(&Arg2));
  \end{Verbatim}
  \end{block}
}

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  CHR Rules zijn ge\"implementeerd:
  \begin{itemize}
    \item Propagation ($ K,\ldots ==> \ldots $)
    \item Simplification ($ R,\ldots <=> \ldots $)
    \item Simpagation ($ K,\ldots \backslash R,\ldots <=> \ldots $)
  \end{itemize}
  
  \begin{block}{voorbeeld}
  \begin{Verbatim}
begin @ init(_) ==> fib(0,1), fib(1,1);
triv @ gcd(0) <=> true;
dec @ gcd(N) \ gcd(M) <=> M>=N | gcd(M-N);
  \end{Verbatim}
  \end{block}
}

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  Variabelen in CHR Rules zijn geimplementeerd:
  \begin{itemize}
    \item Als constraint-argument in head
    \item Als lokale variabele in guard
    \item Als lokale variabele in body
  \end{itemize}
  
  \begin{block}{voorbeeld}
  \begin{Verbatim}
con(N) ==> N>0 | cons(N-1);
con(N) ==> int M=N-1, M>=0 | con(M);
con(N) ==> N>0 | int M=N-1, con(M);
  \end{Verbatim}
  \end{block}
}

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  Het is mogelijk CHR Rules die niet in HNF (Head-Normal Form) staan te gebruiken:
  \begin{itemize}
    \item Er kunnen C-expressies als argument voorkomen
    \item Een variabele mag meermaals voorkomen
    \item Een variabele mag in een expressie voorkomen
  \end{itemize}
  
  \begin{block}{voorbeeld}
  \begin{Verbatim}
con(0) <=> true;
fib(N,_) \ init(N) <=> true;
fib(N-1,M1), fib(N,M2) ==> fib(N+1,M1+M2);
  \end{Verbatim}
  \end{block}
}

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  Het is mogelijk willekeurige C statements in guard of body te plaatsen:
  \begin{itemize}
   \item Moet tussen \{ \ldots \}
   \item Bv initialisatie van ingwikkelde argumenten
  \end{itemize}

  \begin{block}{voorbeeld}
  \begin{Verbatim}
str(Str1) ==> 
  char *Str2=malloc(2*strlen(Str1)), {
    strcpy(Str2,Str1);
    strcat(Str2,Str1;
  }, dblstr(Str2);
  \end{Verbatim}
  \end{block}
}

\frame[containsverbatim]{\frametitle{Mogelijkheden}
  Er is een debug modus:
  \begin{itemize}
    \item Door een optie aan C compiler mee te geven
    \item Print alle constraints, uitgevoerde regels, propagation history toevoegingen, \ldots uit
    \item vereist een debug(``printf string'') tag bij alle constraints
  \end{itemize}
}

\subsection{Overzicht}
\frame{\frametitle{Overzicht}
  \begin{psmatrix}[rowsep=0.3,colsep=0.1]
     \psovalbox{Source} & \\
     & \psovalbox{CCHR} \\
     \psframebox{main} & \psframebox{parser \& lexer} \\
     & \psframebox{analyse} \\
     & \psframebox{code generatie} \\
     \psovalbox{C code + macro's}
     \ncline{->}{1,1}{3,1}
     \ncline{->}{3,1}{2,2}
     \ncline{->}{2,2}{3,2}
     \ncline{->}{3,2}{4,2}
     \ncline{->}{4,2}{5,2}
     \ncline{->}{5,2}{3,1}
     \ncline{->}{3,1}{6,1}
  \end{psmatrix}
}

\frame{\frametitle{Overzicht}
  \begin{block}{de main module}
  \begin{itemize}
    \item Bevat de main() C routine
    \item Overloopt alle opgegeven sourcefiles
    \item Vervangt .chr of .cchr door .c voor output
    \item Kopieert input naar output, behalve cchr-blokken
    \item Voor cchr blokken worden lexer, parser, analyser en code-generator aangeroepen
  \end{itemize}
  \end{block}
}
\frame{\frametitle{Overzicht}
  \begin{block}{de lexer}
  \begin{itemize}
    \item Geschreven mbv. Flex (die lexer genereert in C)
    \item Herkent operatoren, haakjes, symbolen
    \item Parser vraagt deze 'tokens'  op aan lexer
  \end{itemize}
  \end{block}

  \begin{block}{de parser}
  \begin{itemize}
    \item Geschreven mbv. Bison (die parser genereert in C)
    \item Herkent regels, code-blokken, argumenten, constraints, \ldots
  \end{itemize}
  \end{block}
}
\frame{\frametitle{Overzicht}
  \begin{block}{de analyser}
  \begin{itemize}
    \item Analyseert output van de parser (abstract syntax tree)
    \item Genereert nieuwe data structuur met expressions, variabelen, constraints, regels, \ldots
    \item Doet conversie naar Head Normal Form
    \item Analyseert gebruik van variabelen, waar propagation history bij te houden, \ldots
  \end{itemize}
  \end{block}
}
\frame{\frametitle{Overzicht}
  \begin{block}{de code-generator}
  \begin{itemize}
    \item Gebruikt de gegevens gegenereerd door analyser
    \item Genereert een aantal macro's voor elke constraint/regel
    \item Voor elke constraint occurrence een macro met code
  \end{itemize}
  \end{block}
}
\section{Moeilijkheden en ontwerpbeslissingen}
\subsection{Geheugenallocatie}
\frame{\frametitle{Geheugenallocatie}
  Geheugenallocatie:
  \begin{itemize}
    \item Alle ge-malloc()-ed geheugen wordt ge-free()-d
    \item Garbage Collector is niet noodzakelijk, dmv. user-defined destructors
    \item Eventueel kan alternatieve malloc()/free() gebruikt worden (eg. Boehm)
  \end{itemize}
}
\subsection{Macro's}
\frame{\frametitle{Gebruik van C macro's}
  Gebruik van C macro's:
  \begin{block}{voordelen}
  \begin{itemize}
    \item Minder echte code in CCHR compiler zelf (hardcoded)
    \item Keuze van eg. datastructuren kan buiten compiler
    \item Overzichtelijkere outputcode
    \item Debug-mode door simpel optie meegeven aan C compiler
  \end{itemize}
  \end{block}
  \begin{block}{nadelen}
  \begin{itemize}
    \item Veel moeilijker locatie van bugs te vinden
    \item Macro definities redelijk moeilijk leesbare code
  \end{itemize}
  \end{block}
}
\section{Performantie}
\frame{\frametitle{Algemeen}
  \begin{itemize}
    \item HW: AMD Athlon64 3500+, 1Gb PC3200 DDR RAM
    \item C Compiler: GCC 4.1.1, -O3 -march=athlon64
    \item Java: Sun JRE 1.5 64-bit Hotspot; JCHR 1.5
    \item Prolog: v5.6.24 for amd64
  \end{itemize}
}
\subsection{GCD Voorbeeld}
\frame[containsverbatim]{\frametitle{GCD Voorbeeld}
  \begin{Verbatim}
constraint gcd(uint64_t);
triv @ gcd(0ULL) <=> true;
dec @ gcd(N) \ gcd(M) <=> M>=N | gcd(M-N);
  \end{Verbatim}
  \vspace{2ex}
  Beginnen met: gcd(100000000),gcd(5). \\
  \vspace{2ex}
  \begin{block}{resultaten}
  \begin{tabular}{c|cc}
    implementatie & runtime & cycles/iteratie \\
    \hline
    swi-prolog & 37.1s & 4100 \\
    cchr       & 0.08s & 8.8 \\
  \end{tabular}
  \end{block}
  \vspace{2ex}
  Java heeft geen tail recursion $\rightarrow$ stack overflow
}
\subsection{FIB Voorbeeld}
\frame[containsverbatim] {
\frametitle{FIB Voorbeeld (met GMP library)}
\scriptsize \begin{Verbatim}
typedef struct { mpz_t v; } bigint_t;
  
constraint fib(int,bigint_t) destr(mpz_clear(Arg2.v));
constraint init(int);
  
begin @ init(_) ==> bigint_t Z=, bigint_t Y=, {
    mpz_init_set_si(Z.v,1);
    mpz_init_set_si(Y.v,1);
  }, fib(0,Z), fib(1,Y);
  
calc @ init(Max), fib(N-1,M1), fib(N,M2) ==> N<Max | 
  bigint_t Sum=, {
    mpz_init(Sum.v);
    mpz_add(Sum.v,M1.v,M2.v);
  }, fib(N+1, Sum);
  
fini @ init(_) <=> true;
\end{Verbatim}
}


\frame[containsverbatim]{\frametitle{FIB Voorbeeld: resultaten}
  Beginnen met: init(7499). \\
  Versie 2 gebruikt:
\begin{Verbatim}
  fini @ fib(Max,_) \  init(Max) <=> true;
\end{Verbatim}
in plaats van:
\begin{Verbatim}
  fini @ init(_) <=> true;
\end{Verbatim}
  \vspace{2ex}
  \begin{block}{resultaten}
  \begin{tabular}{c|cc}
    implementatie & runtime(v1) & runtime(v2) \\
    \hline
    swi-prolog & 740s & 294s \\
    jchr & 4.56s & 0.149s \\
    cchr & 2.06s & 1.22s \\
    cchr (no hist) & - & 0.505s
  \end{tabular}
  \end{block}
}

\subsection{Primes voorbeeld}
\frame[containsverbatim] {
\frametitle{Primes voorbeeld}

\small \begin{Verbatim}
constraint candidate(int),prime(int);
candidate(1) <=> true;
candidate(N) <=> prime(N), candidate(N-1);
prime(Y) \  prime(X) <=> (X%Y)==0 | true;
\end{Verbatim}
  Beginnen met: candidate(23000). \\
  \vspace{2ex}
  \begin{block}{resultaten}
  \begin{tabular}{c|c}
    implementatie & runtime \\
    \hline
    swi-prolog & 330s \\
    jchr & 48.5s \\
    cchr & 8.9s
  \end{tabular}
  \end{block}
}

\section{Gepland werk}
\subsection{Gepland werk}
\frame{\frametitle{Gepland werk}
  \begin{itemize}
    \item Meer optimalisaties (statische analyse)
    \item Built-in constraints (mbv. union find) \& reactivatie
    \item Meer datastructuren (eg. hashtables)
    \item Functies om over constraint store te itereren
    \item Parameters bij rules (pragma's, eg. ``passive'')
  \end{itemize}
}

\frame{\frametitle{Einde}
  Nog vragen?
}
\end{document}
