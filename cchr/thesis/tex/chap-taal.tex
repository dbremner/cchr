\chapter{De Taal}

In dit hoofdstuk wordt ingegaan op de taal ontwikkeld om CHR in C mogelijk te maken: CCHR.

Het doel van deze thesis was nagaan hoeveel effici\"enter dan bestaande CHR systemen een implementatie
in C kon zijn. De doelstellingen waar de taal aan moet voldoen zijn dan ook: \begin{itemize}
  \item We willen een taal ontwerpen die mogelijk maakt CHR en C te integreren: de CHR code moet C
        als host language kunnen gebruiken (C constructies als ``built-in constraints'' kunnen
	behandelen), en de C code moet bijvoorbeeld omgekeerd ook CHR constraints kunnen laten toevoegen.
  \item De taal moet het mogelijk maken heel efficiente code te genereren.
\end{itemize}

\section{Algemeen}

Om de integratie van C en CHR mogelijk te maken, zullen we een ``cchr'' blok toelaten binnenin een stuk normale C code, wat vervangen zal worden door een cchr-compiler door een stuk equivalente pure C code. In die zin moet CCHR dan ook eerder als een taal-uitbreiding van C beschouwd worden, en niet als aparte taal. Alle C taal-elementen die de omgeving wijzigen in de ``omhullende'' C code zijn automatisch ook van toepassing op CHR (bv. \#include directives). 

\section{Syntax}

De algemene syntax bedacht om CHR met C te kunnen integreren, is sterk ge\"inspireerd door K.U.Leuven JCHR, waar CHR handlers geschreven worden binnen een specifiek blok in een bestand met \code{.jchr} extensie. In CCHR zullen we echter niet eisen dat de CHR handler code zich in een apart bestand bevindt, om de mogelijke interacties tussen C en CHR niet te beperken. C verschilt hierin van Java, aangezien in C niet enkel functie-aanroepen zinvolle interacties zijn (zoals methode-aanroepen in Java), maar ook macro-definities, inline-functies, \ldots, die enkel mogelijk zijn of betekenis hebben binnen hetzelfde bronbestand.

Om de syntax in te leiden, is het interessant te beginnen met een eenvoudig voorbeeld (zie voorbeeld~\ref{fib:exCode}). Dit programma berekent opeenvolgende {\em ``getallen van Fibonacci''}. Deze getallen zijn gedefinieerd als een rij waarbij elk getal de som is van de 2 voorgaande.

\begin{exCode}
\begin{Verbatim}[frame=single,numbers=left]
#include <stdio.h>
#include <stdlib.h>

#include "fib_cchr.h"

cchr {
  constraint fib(int,long long),init(int);

  begin @ init(_) ==> fib(0,1LL), fib(1,1LL);
  calc @  init(Max), fib(N2,M2) \ fib(N1,M1) <=>
    alt(N2==N1+1,N2-1==N1), N2<Max |
    fib(N2+1, M1+M2);
}

int main(int argc, char **argv) {
  cchr_runtime_init();
  cchr_add_init_1(90);
  cchr_consloop(j,fib_2,{
    printf("fib(%i,%lli)\n", 
      cchr_consarg(j,fib_2,1),
      (long long)cchr_consarg(j,fib_2,2));
  });
  cchr_runtime_free();
  return 0;
}
\end{Verbatim}
\caption{\label{fib:exCode} Fibonacci-voorbeeld}
\end{exCode}

\subsection{Het cchr-blok}

Een CCHR bronbestand bevat steeds een ``cchr''-blok, ingeluid met het sleutelwoord \code{cchr} en gevolgd door een stuk code tussen accolades. Dit stuk code zal vervangen worden door een equivalent stuk C broncode. Er zal tevens een header gegenereerd worden met dezelfde bestandsnaam als het bronbestand, maar \code{.cchr} vervangen door \code{\_cchr.h}, en definities bevatten zodat met de CHR handler geinterageert kan worden. In voorbeeld~\ref{fib:exCode} kan u het cchr blok zien op lijn 6 tot lijn 13. Lijn 4 bevat de opname van dat header bestand. Om problemen met recursieve definities op te lossen, is het nodig dit bestand op te nemen voor het cchr blok.

Binnen het cchr-blok gelden dezelfde algemene regels als in C zelf: \begin{itemize}
  \item Commentaar wordt begonnen door \code{//} (tot op het einde van de lijn), of door \code{/*} (tot aan de eerstvolgende \code{*/}).
  \item Spaties en andere witruimte (nieuwe lijnen) hebben geen betekenis (tenzij als scheiding tussen 2 symboolnamen of operatoren).
\end{itemize}

\subsection{Constraints}

Constraints (zoals op lijn 7 van het voorbeeld), volgen JCHR's syntax: het \code{constraint} sleutelwoord gevolgd door een lijst van 1 of meer constraint namen, met tussen haakjes hun respectievelijke argumenten-types. Constraints zonder argument vereisen nog steeds \code{()} erachter, net zoals C ook een lege argumentenlijst vereist voor functies zonder argumenten (dit verschil van JCHR).

Het is ook mogelijk om enkele opties aan te geven over constraints. Deze worden genoteerd door achter de argumenten van een constraint ``\code{option(}$optienaam$\code{,}$args$\ldots\code{)}'' te zetten (meerdere options mogelijk). Een lijstje van de
toegelaten opties: \begin{itemize}
  \item \code{fmt}: een standaard C printf formatstring, voor gebruik in debugmodus, om constraint suspensions te kunnen
    uitprinten. Na deze formatstring volgen de argumenten dat de formatstring zelf nodig heeft te komen, waarbij naar de
    argumenten van de uit te printen constraints verwezen kan worden met \code{\$1}, \code{\$2}, \ldots.
  \item \code{init}: Een stuk C code dat uitgevoerd wordt bij het aanmaken van een constraint suspension van dit type.
    het kan een functie, een macro of gewoon een stuk code zelf zijn.
  \item \code{destr}: Een stuk C code dat uitgevoerd wordt bij het vernietigen van een constraint suspension van dit type. 
  \item \code{add}: Een stuk C code dat uitgevoetd bij bij het toevoegen van een constraint suspension van dit type in de
    constraint store. Hierbij kan naar de huidige constraint suspension verwezen worden met \code{\$0} (\code{\$0} is van het type \code{cchr\_id\_t}).
  \item \code{kill}: Een stuk C code dat uitgevoerd wordt bij het verwijderen van een constraint suspension van dit type
    uit de constraint store.
\end{itemize}

Het is niet mogelijk (in tegenstelling tot JCHR) om constraints met infix notatie te gebruiken. C zelf ondersteunt ook geen ``operator overloading'', dus deze functionaliteit leek overbodig.

\subsection{Symbolen}

Geldige namen voor constraints, functies, variabelen en andere C symbolen zijn letters (kleine en hoofdletters), cijfers en de underscore (\code{\_}). Het eerste teken mag echter geen cijfer zijn. Alle namen die met een hoofdletter beginnen kunnen als CHR variabele gebruikt worden, maar een naam (die nog niet eerder voorkwam) op een plaats gebruiken waar geen variabele gedefinieerd kan worden (zie verder) zal ervoor zorgen dat die als extern C symbool beschouwd wordt. Het is ook mogelijk een bepaalde naam sowieso als extern symbool te doen beschouwen, door het achter een ``\code{extern}'' sleutelwoord te zetten binnen het cchr-blok.

\subsection{Rules}

De syntax voor het noteren van CCHR regels is grotendeels gebaseerd op JCHR (waarvan de syntax sterk aanleunt bij de
originele CHR syntax). Ze bestaat uit \begin{enumerate}
  \item Een (optionele) benaming voor de regel, gevolgd door een \code{@}-symbool.
  \item Een of meerdere head-constraints, met argumenten (CHR variabelen of C expressies, zie verder), gescheiden door komma's.
  \item Eventueel een backslash (\code{$\backslash$}) gevolgd door nog een of meer head-constraints (removed constraints, in geval van simpagation rule)
  \item Een regel-type aanduider (\code{==>} voor propagation of \code{<=>} voor simplification of simpagation).
  \item Eventueel een guard, gevolgd door een pijp-symbool (\code{|}).
  \item De body van de CHR regel.
  \item Afgesloten mbv. een puntkomma (\code{;}).
\end{enumerate}

Er zijn enkele verschillen met JCHR: \begin{itemize}
  \item De regels staan niet in een apart \code{rules} blok. Dit lijkt een overbodige erfenis uit JaCK.
  \item Regels eindigen niet op een punt maar op een puntkomma (Dit zorgt voor ambigu\"iteit aangezien het punt een geldige
        C operator is).
\end{itemize}

\subsubsection{Head}

De ``head'' constraints van een CHR regel (bestaande uit removed constraints en kept constraints) worden zoals vermeld genoteerd door comma's gescheiden lijsten. Alle constraint-namen moeten in hetzelfde cchr-blok gedeclareerd zijn mbv. het \code{constraint} sleutelwoord, en hun aantal argumenten (de ariteit) moet overeenkomen. Het is trouwens wel toegelaten meerdere constraints met dezelfde naam maar verschillende ariteit te hebben. Als argumenten kunnen CHR variabelen voorkomen (nieuwe), of gelijk welke C expressie die eventueel gebruik maakt van eerder gebruikte CHR variabelen. 

Variabelen die met een underscore (\code{\_}) beginnen, worden als anoniem beschouwd. Dat wilt zeggen dat ze niet meer verder gebruikt zullen worden. Dit gedrag komt overeen met Prolog's anonieme variabele (de underscore zelf), maar net zoals JCHR wordt toegestaan dat er nog andere letters volgen (wat leesbaarheid ten goede kan komen).

\subsubsection{Guard en Body}

Er is grote vrijheid aan wat als guard of body bruikbaar is in CCHR: \begin{enumerate}
  \item (enkel als guard) Een willekeurige C expressie, die tot 0 of niet-0 evalueert (false of true).
  \item Een lokale variabele definitie.
  \item Een stuk arbitraire C code (tussen accolades).
  \item (enkel als body) Een toe te voegen constraint
\end{enumerate}

Binnen een guard is er een speciaal sleutelwoord mogelijk: \code{alt}: het dient om 2 of meer logisch equivalente expressies te geven. Dit kan optimalisaties helpen, die steunen op een bepaalde betrekking die uit een guard afgeleid kan worden.

Lokale variabelen binnen een guard of body gebruiken kennen een eigen syntax, die verschilt van die van JCHR. Het volstaat om een datatype, gevolgd door een variabelenaam (die niet eens met een hoofdletter moet beginnen), een gelijkheidsteken, en eventueel een expressie voor initializatie te noteren. Een voorbeeldje: \begin{Verbatim}
  calc @ init(Max), fib(N,A) \ fib(N+1,B) <=> int sum=A+B, fib(N+2,sum):
\end{Verbatim}

\subsubsection{Macros}

Het is mogelijk om binnen het CCHR blok zelf verkorte notaties in te voeren voor gebruik binnen de body van CHR rules. Een voorbeeldje: \begin{Verbatim}
  macro eq(bigint_t,bigint_t) bigint_cmp($1,$2);
  macro eq(_,_) ($1==$2);
\end{Verbatim}

Dit zal het mogelijk maken om 2 \code{bigint\_t} variabelen met elkaar te vergelijken mbv. \code{eq(a,b)}, maar ook 2 andere variabelen mbv. de C operator \code{==}. (het dattype \code{bigint\_t} zou elders gedefinieerd moeten zijn).

Zoals te zien is laat deze techniek toe dat verschillende data-types als parameters gebruikt worden (een soort polymorfisme), of dat \code{\_} als joker voor elk willekeurig type kan dienen. Indien er meerdere macrodefinities van toepassing zijn, wordt de eerste gebruikt. De datatypes zijn echter enkel bekend voor pure variabelen, gedefini\"eerd in de head van een regel, of als lokale variabele. Ingewikkeldere expressies die geen variabele voorstellen, kunnen enkel overeenkomen met het jokertype \code{\_}.

Het nut van deze macros is een equivalent voorzien voor de {\em built-in constraints} van JCHR. In een latere uitbreiding zouden deze macros automatisch gegenereerd kunnen worden door het inladen van een extra module.

\section{Variabelen}

\subsection{Waarde en Betekenis}

In C is de waarde van een variabele altijd gewoon de inhoud van het geheugenadres waar de variabele opgeslagen is. In CCHR wordt ge\"eist dat de waarde van constraint-argumenten constante waardes hebben (deze eis laten zou voor veel moeilijkheden kunnen zorgen, waaronder moeilijk te defini\"eren gedrag). Dat wilt daarom echter niet zeggen dat het onmogelijk is om de betekenis van een variabele te wijzigen, die van meer kan afhangen dan enkel de waarde. 

Dat laatste is vaak nodig om in CHR het resultaat van een berekening terug te geven. Zoals in dit voorbeeld (in Prolog-CHR): \begin{Verbatim}
  calcMin1 @ min(N1,N2,R) <=> N1=<N2 | R=N1.
  calcMin2 @ min(_,N2,R) <=> R=N2.
\end{Verbatim}
In dit voorbeeld zal het toevoegen van \code{min(A,B,C)} tot gevolg hebben dat R ge\"unificeerd wordt met de kleinste van A en B.

Wanneer de betekenis van variabelen kan veranderen (en dat is waar guards indirect op controleren) het mogelijk kan zijn dat
reactivtatie nodig is.

\subsection{Pointers}

Een van de belangrijkste opzichten waarin C van recentere programmeertalen verschilt, is de mogelijkheid tot direct geheugenbeheer. Een C-programmeur kan zijn programma eender wat laten doen met het deel (virtueel) geheugen dat het (kan) krijgen van het systeem. Of dat de begrijpbaarheid van de erin geschreven programma's ten goede komt, laten we hier in het midden, maar het blijft een taalconstructie die voor veel mogelijkheden zorgt.

Pointers zijn 1 mogelijkheid om een constraint argument met vaste waarde toch van betekenis te doen veranderen. In CCHR
zou bovenstaand voorbeeld opgelost kunnen als volgt: \begin{Verbatim}
  constraint min(int,int,int*); /* int* = pointer to int */
  calcMin1 @ min(N1,N2,R) <=> N1<=N2 | { *(R)=N1 };
  calcMin2 @ min(_,N2,R) <=> { *(R)=N2 };
\end{Verbatim}

In dit voorbeeld is het laatste argument van \code{min} een pointer naar een \code{int} waarin het resultaat geplaatst wordt. De
waarde van dat laatste argument blijft zolang de constraint bestaat hetzelfde (zijnde een verwijzing naar dezelfde
geheugenplaats), maar de betekenis (zijnde hetgeen op die bepaalde plaats staat) wijzigt.

In dit voorbeeld, waar de pointer louter gebruikt wordt om een waarde terug te geven (vrij vergelijkbaar met het call-by-reference principe in imperatieve programmeertalen). Wanneer de betekenis van een dergelijke indirecte variabele echter als guard gebruikt zou worden, ontstaan er problemen: \begin{Verbatim}
  constraint facmult(int*,int*);
  calcFac @ facmult(N,V) ==> *(N)>0 | { *(V) *= *(N); *(N)--; };
\end{Verbatim}

De bedoeling van dit CCHR programma (als het aan de {\em CHR refined operational semantics} voldoet) zou zijn dat wanneer er een \code{facmult(\argu{N},\argu{V})} constraint bestaat, er zodra \code{*N} op $x$ (groter dan \code{0}) gezet wordt, \code{*N} terug nul wordt, en \code{*V} vermenigvuldigd met $x!$. Het is echter moeilijk (zo niet onmogelijk) om (effici\"ent) te controleren wanneer de waarde van een expressie gewijzigd kan zijn, zeker in combinate met bv. pointers die kunnen wijzen naar geheugenplaatsen die buiten de controle van het programma zelf kunnen wijzigen (denk bijvoorbeeld aan {\em Shared Memory} (SHM) technieken waarbij een deel (virtueel) geheugen gedeeld kan worden tussen verschillende programmas).

Daarom wordt gesteld dat de CCHR programmeur zelf verantwoordelijk is voor aanduiden wanneer een expressie die als guard gebruikt
wordt gewijzigd kan zijn. De syntax hiervoor wordt in de volgende sectie aangereikt.

\subsection{Logische variabelen}

Om de mogelijkheden van CHR in C niet te beperken, is er ook ondersteuning voor echte logische variabelen. Ze worden, echter
algemeen voor C voorzien, buiten CCHR om. Ze zorgen dat logische {\em built-in constraints} gebruikt kunnen worden in
CCHR. Dit houdt in: \begin{itemize}
  \item Een waarde geven (een logische variabele heeft niet noodzakelijk een waarde).
  \item De waarde opvragen
  \item Stellen dat een logische variabele gelijk is aan een andere logische variabele
  \item Controleren of 2 logische variabelen aan elkaar gelijk zijn
\end{itemize}

Logische variabelen hebben ook de mogelijkheid om door de programmeur gespecifieerde routines aan te roepen bij bepaalde acties. Dit kan het bekendmaken dat reactivatie nodig kan zijn aanzienlijk vereenvoudigen. 

\TODO{Logische variabelen syntax}

\section{C routines}

Tot hiertoe hebben we de mogelijkheden beschreven die CCHR code biedt. Het is echter ook noodzakelijk te specifi\"eren hoe C code kan interageren met de CCHR constraints. We gaan even in op alle C routines die ter beschikking gesteld worden. Deze routines zullen in praktijk C functies of macros zijn. Sommigen zijn algemeen voor een cchr-blok, en andere zijn specifiek voor bepaalde constraints.

\subsection{Initializatie en terminatie}

Vooraleer een CCHR constraint aan de {\em constraint store} mag toegevoegd worden, moet de store zelf ge\"initializeerd worden. Achteraf, wanneer geen gebruik van CCHR meer nodig zou zijn, is het mogelijk alle geheugen geassocieerd met CCHR (inclusief de constraint store en alle constraint suspensions die erin opgeslagen zitten) terug vrij te geven. Dit gebeurt met de routines:
\begin{Verbatim}
  cchr_runtime_init();
  cchr_runtime_free();
\end{Verbatim}

\subsection{Toevoegen van constraints}

Vooraleer iets nuttig met CCHR gedaan kan worden, zal het nodig zijn tenminste \'e\'en constraint aan de store toe te voegen. Om dit te doen wordt per constraint volgende functie voorzien: \begin{Verbatim}[commandchars=\\\{\}]
  void cchr_add_\argu{constraint}_\argu{ariteit}(\argu{arg1},\argu{arg2},\ldots);
\end{Verbatim}

\subsection{Reactivatie}

Soms is het nodig de CCHR runtime te informeren dat de waarde van een expressie in een guard gewijzigd zou. Hier worden volgende routines voor voorzien: \begin{Verbatim}[commandchars=\\\{\}]
/* alle constraint suspensions */
  cchr_reactivate_all(); 
/* alle constraint suspensions van bepaalde constraint */
  cchr_reactivate_all_\argu{constraint}_\argu{ariteit}();
/* enkel bepaalde constraint suspension */
  cchr_reactivate_\argu{constraint}_\argu{ariteit}(cchr_pid_t {\em{PID}});
\end{Verbatim}

\subsection{Iteratie}

Uiteindelijk moet het mogelijk zijn de inhoud van de constraint store op te vragen. Hiervoor is volgende routine voorzien: \begin{Verbatim}[commandchars=\\\{\}]
  cchr_consloop(\argu{var},\argu{constraint}_\argu{ariteit},\argu{code})
\end{Verbatim}
\argu{code} is hierbij een stuk arbitraire C code kan bevatten dat voor elke constraint van type \argu{constraint} en ariteit \argu{ariteit} doorlopen wordt. Binnen \argu{code} kan verwezen worden naar de argumenten van de betrokken constraint met behulp van: \begin{Verbatim}[commandchars=\\\{\}]
  cchr_consarg(\argu{var},\argu{constraint}_\argu{ariteit},\argu{num})
\end{Verbatim}
waarbij \argu{num} naar het argument nummer $num$ verwijst (te beginnen tellen vanaf $1$).
