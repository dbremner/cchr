\chapter{Constraint Handling Rules}

In dit hoofdstuk zullen we een overzicht geven van de taal CHR.

\section{Inleiding}

CHR is een hoog-niveau, declaratieve taaluitbreiding voor CLP. Het geeft de mogelijkheid om in een gegeven host-taal die reeds enkele {\em built-in constraints} ondersteunt, nieuwe door de gebruiker gedefini\"eerde constraints (ofwel CHR constraints) te gaan toevoegen. CHR geeft dan een mogelijkheid te specifi\"eren hoe deze CHR constraints, die door een programma in de host-taal toegevoegd kunnen worden, omgezet worden in verschillende stappen tot nieuwe CHR constraints, en built-in constraints.

CHR staat voor Constraint Handling Rules, en bestaat uit een opsomming van regels die beschrijven hoe en wanneer CHR constraints herschreven mogen worden tot andere constraints. We zullen hier een beschrijving geven van CHR in te bedden in Prolog, wat gebruikelijk is. Op die manier kan de CHR syntax en semantiek het gemakkelijkst beschreven worden. Bij het inbedden van CHR in een imperatieve taal zijn vaak enkele omwegen nodig om de hosttaal als CLP taal te kunnen gebruiken. De built-in constraints die Prolog aanbiedt zijn zijn \code{=} (unificatie), \code{==} (termgelijkheid), gebruiker-gedefinieerde predikaten en enkele ingebouwde predikaten.

\subsection{Syntax}

Constraints nemen de vorm aan van predikaten, met een naam en een ariteit. Ze moeten op een of andere manier gedeclareerd worden als constraint, ipv. normaal predikaat. In Prolog CHR gebeurt dat met: \begin{Verbatim}
  :- chr_constraint upto(+int),prime(+int).
\end{Verbatim}
Hiermee wordt duidelijk gemaakt dat \code{upto/1} en \code{prime/1} geen predikaten maar constraints zijn.

Voor de rest kunnen er nu CHR rules gegeven worden, die beschrijven hoe de gebruikers-gedefinieerde constraints \code{fib/2} behandeld moet worden. Er zijn 3 types van CHR rules: \begin{itemize}
\item Simplification: Een regel die aangeeft dat onder een bepaalde voorwaarden, bepaalde CHR constraints verwijderd mogen worden en er andere in de plaats komen. De algemene syntax is:  $naam @ R_1, R_2, \ldots <=> G_1, G_2, \ldots | A_1, A_2, \ldots.$. $R_i$ zijn hierbij de constraints na het uitvoeren van de regel verwijderd mogen worden (``removed constraints''), $G_i$ de voorwaardes waaraan voldaan moet zijn (``guards''), en $A_i$ de constraints die toegevoegd moeten worden (``added constraint''). Zulk een regel wordt gebruikt om een vereenvoudiging toe te laten. Het $naam @$ gedeelte is optioneel, net als het $G_i, \ldots |$ gedeelte, indien er geen $G_i$'s zijn.
\item Propagation: een regel die dat onder bepaalde voorwaardes, bepaalde CHR constraints toegevoegd mogen worden. De syntax is: $naam @ K_1, K_2, \ldots ==> G_1, G_2, \ldots | A_1, A_2, \ldots.$. $K_i$ zijn hierbij de constraints die reeds moeten bestaan (``kept constraints''), $G_i$ en $A_i$ zijn gelijkaardig aan het vorige voorbeeld.
\item Simpagation: Een combinatie van Propagation en Simplification. De syntax is $naam @ K_1, K_2, \ldots \backslash R_1, R_2, \ldots <=> G_1, G_2, \ldots | A_1, A_2, \ldots.$. Hierbij moeten zowel de kept als de removed constraints bestaan, en aan de guards voldaan zijn, en zullen de removed constraint verwijderd worden en de added constraints toegevoegd.
\end{itemize}

Een vollediger voorbeeldje:
\begin{Verbatim}
  simplification @ upto(X) <=> X<2 | true.
  propagation @ upto(X) ==> X>1 | Y is X-1, upto(Y), prime(X).
  simpagation @ prime(X) \ prime(Y) <=> Z is Y mod X, Z==0 | true.
\end{Verbatim}

